{
  "values": [
    "    Основы администрирования программно-аппаратных комплексов под управлением ОС Linux\n  Уровень\n(наименование дисциплины (модуля) в соответствии с учебным планом)\nспециалитет\n  Форма обучения\nНаправление(-я) подготовки\nИнститут Кафедра Лектор\nРТУ МИРЭА ЛЕКЦИОННЫЕ МАТЕРИАЛЫ\nочная\nкомплексной безопасности и приборостроения (КБСП)\nк.т.н., Потерпеев Герман Юрьевич\nМИНОБРНАУКИ РОССИИ\nФедеральное государственное бюджетное образовательное учреждение высшего образования\n«МИРЭА – Российский технологический университет»\n (бакалавриат, магистратура, специалитет)\n   (очная, очно-заочная, заочная)\n  10.05.04 «Информационно-аналитические системы безопасности»\n  (код(-ы) и наименование(-я))\n        (полное и краткое наименование)\n КБ-2 (Прикладные информационные технологии)\n  (полное и краткое наименование кафедры, реализующей дисциплину (модуль))\n           (сокращенно – ученая степень, ученое звание; полностью – ФИО)\n Используются в данной редакции с учебного года\n 2018/19\n     (учебный год цифрами)\n  Проверено и согласовано «____» ________20___г. Москва 20__ г.\n       (подпись директора Института/Филиала\n  с расшифровкой)\n     \nЛЕКЦИЯ No1\n«Современные ОС семейства Linux» по дисциплине\n«Основы администрирования программно-аппаратных комплексов под управлением ОС Linux»\n1)Современные ОС семейства Linux 2)Классификация современных ОС семейства Linux\n1)Современные ОС семейства Linux. История развития Linux.\nLinux — общее название UNIX-подобных операционных систем на основе одноимѐнного ядра и собранных для него библиотек и системных программ, разработанных в рамках проекта GNU. GNU/Linux работает на PC-совместимых системах семейства Intel x86, а также на IA-64, AMD64, PowerPC, ARM и многих других.\nК операционной системе GNU/Linux также часто относят программы, дополняющие эту операционную систему, и прикладные программы, делающие еѐ полноценной многофункциональной операционной средой. В отличие от большинства других операционных систем, GNU/Linux не имеет единой «официальной» комплектации. Вместо этого GNU/Linux поставляется в большом количестве так называемых дистрибутивов, в которых программы GNU соединяются с ядром Linux и другими программами.\nКорни Linux уходят в два других проекта: Unix и Multics, которые ставили своей целью разработать многопользовательскую операционную систему.\nЧто такое Unix?\nUnix – это собрание кроссплатформенных многопользовательских и многозадачных операционных систем.\nМожно сразу сказать, что в данный момент Unix-системы являются одними из самых исторических важных операционных систем. Влияние Unix распространилось и на языки программирования: язык C был разработан во время разработки Unix-систем.\nРазработкой Unix занималась корпорация Bell Laboratories – в 1969 году они показали первую систему Unix. Чем дальше, тем большую популярность обретали системы Unix - в 70-х их начали устанавливать на компьютеры в учебных заведениях.\nПри создании Unix разработчики поставили перед собой три основные задачи:\nИспользование минимального количества функций, сохранение простоты.\n\nОбщность: одинаковые методы и механизмы используются в разных случаях.\nКомбинирование программ для решения задач, а не разработка новых программ с нуля.\nЧто касается отличительных особенностей Unix, то это:\nПрактически постоянное использование командной строки.\nИспользование конвейнеров.\nНастройка системы через использование простых (зачастую текстовых) файлов.\nUnix имеет свою собственную философию. Программист Дуглас Макилрой, который разработал конвейнер в Linux, определил следующие правила:\nПишите программы, которые делают что-то одно и делают это хорошо. Пишите программы, которые бы работали вместе.\nПишите программы, которые бы поддерживали текстовые потоки, поскольку это универсальный интерфейс.\nОдна из проблем, коснувшаяся Unix, - наличие разных версий и множества программ, которые писали разработчики под свои нужды; из-за низкой совместимости программы, работающие с одной версией Unix, могли не работать на машинах с другими версиями. В итоге было решено создать общий документ, в котором будут указаны стандарты, которым должны следовать разработчики.\nВ 1983 году было объявлено о создании GNU (GNU’s Not UNIX), Unix-подобной операционной системы. Произошло это под влиянием идеи основателя проекта Ричарда Столманна о необходимости создания свободно распространяемой операционной системы и вообще программного обеспечения с открытым исходным кодом.\nРичард Столманн также основан движение свободного программного обеспечения и сформулирован четыре права, которыми должен обладать пользователь: он может запускать программу для любых целей, он может изучать программы и изменять их согласно своим потребностям, он может распространять программу, чтобы помочь другим, и он может публиковать улучшения программы, чтобы помочь сообществу в целом. Все это в первую очередь говорило о том, что исходный код программы должен быть доступен всем.\nИменно эта мысль вдохновила Линуса Торвальдса, создателя Linux, начать в 1991 году работу над своей операционной системой. Linux, как и GNU, это Unix-подобная система, то есть система, появившаяся под влиянием Unix.\n\nВ дальнейшем именно система GNU/Linux станет той системой, которую сейчас называют просто Linux.\nЧто такое Multics?\nMultics — или Multiplexed Information and Computing Service («Мультиплексная информационная и вычислительная служба») — это одна из самых первых операционных систем, в которой была реализована плоская модель хранения данных и четко разделена концепция файлов (сегментов). Создание Multics началось в 1964 году. Над системой работали разработчики компании Bell Laboratories — через несколько лет часть разработчиков начнет работу над созданием Unix.\nMultics разрабатывали для того, чтобы, во-первых, дать возможность использовать ресурсы ЭВМ большому количеству пользователей одновременно; во-вторых, дать пользователям возможность совместно использовать данные; в-третьих, обеспечить хорошую скорость работы с данными.\nОднако главные вычислительные задачи не были достигнуты при выпуске первой версии системы, и компания Bell Laboratories перевела свой интерес на другой проект, в результате которого на свет появился Unix.\nИстория Linux\nИстория Linux начинается в 1991 году, когда финский программист Линус Торвальдс стал разрабатывать ядро операционной системы для своего компьютера. Свои наработки он выложил на сервере, и это стало ключевым событием в истории Linux. Сначала десятки, потом сотни и тысячи разработчиков поддержали его проект - общими усилиями на свет появилась полноценная операционная система.\nКак уже было сказано, на Linux значительно повлияла система Unix, это заметно даже по названию. Впрочем, изначально проект назывался Freax - от слов ―free‖ (бесплатный) и ―freak‖ (странный), но в дальнейшем название было изменено на гибрид имени создателя (Линус) и Unix.\nЭмблемой Linux стал Такс (Tux) - пингвин, нарисованный в 1996 году программистом и дизайнером Ларри Юингом. Впрочем, идею использовать именно пингвина придумал сам Линус Торвальдс. Теперь Такс является символом не только Linux, но и свободного программного обеспечения в целом.\nПервая официальная версия Linux 1.0 вышла в 1994 году; вторая версия пошла в 1996 году. Товарный знак Linux был зарегистрирован на год раньше, в 1995.\nС самого начала и по сей день Linux распространяется как свободное программное обеспечение с лицензией GPL. Это значит, что исходный код операционной системы может увидеть любой пользователь - и не только увидеть, но и доработать его. Единственное условие - измененный, модифицированный код должен быть так же доступен всем и распространяться по лицензии GPL. Это важно, так как дает возможность разработчикам использовать код и в то же время не бояться проблем из-за авторских прав.\n\nСвоему успеху Linux во многом обязан GNU: на момент выхода Linux существовало уже много свободного распространяемых утилит этого проекта, которые можно было использовать с разработанным ядром.\nПо факту Linux до сих представляет собой ядро Unix-подобной операционной системы, которое выполняет различные низкоуровневые задачи. В то же время проект GNU нуждался в ядре - разработка Линуса Торвальдса была очень своевременной.\nСейчас благодаря своей гибкости Linux используется на множестве разных устройств, начиная от компьютеров и заканчивая серверами и мобильными устройствами.\nДистрибутив Linux – это определение операционной системы, которая использует ядро Linux, и которую можно установить на машину пользователя. В дистрибутивах обычно содержатся не только ядро и сама операционная система, но и полезные приложения: редакторы, проигрыватели, инструменты для работы с базами данных и другое программное обеспечение.\nТо есть, как уже было сказано в начале статьи, дистрибутив Linux – это операционная система, которая состоит из ядра Linux и утилит, которые разрабатываются в рамках GNU. Количество существующих дистрибутивов Linux превышает 600 разновидностей, более 300 из которых постоянно дорабатываются и обновляются.\n2)Классификация современных ОС семейства Linux\nБольшинство пользователей для установки GNU/Linux используют дистрибутивы. Дистрибутив — это не просто набор программ, а ряд решений для разных задач пользователей, объединѐнных едиными системами установки, управления и обновления пакетов, настройки и поддержки.\nСамые распространѐнные в мире дистрибутивы:\nUbuntu\nБыстро завоевавший популярность дистрибутив, ориентированный на лѐгкость в освоении и использовании.\nLinux Mint\nLinux Mint - дистрибутив, основанный на Ubuntu и Debian. Linux Mint обладает красивым и удобным дизайном и подойдет даже начинающим пользователям. Поэтому его часто устанавливают на домашние компьютеры для того, чтобы иметь простую и удобную систему. Дистрибутив имеет поддержку различных мультимедийных форматов, в том числе включает проприетарные программы (Adobe Flash), поэтому хорошо подходит для работы с мультимедиа.\n  \nopenSUSE\nБесплатно распространяемая версия дистрибутива SuSE, принадлежащая компании Novell. Отличается удобством в настройке и обслуживании благодаря использованию утилиты YaST.\nFedora\nПоддерживается сообществом и корпорацией RedHat, предшествует выпускам коммерческой версии RHEL.\nDebian\nМеждународный дистрибутив, разрабатываемый обширным сообществом разработчиков в некоммерческих целях. Послужил основой для создания множества других дистрибутивов. Отличается строгим подходом к включению несвободного ПО.\nMandriva\nФранцузско-бразильский дистрибутив, объединение бывших Mandrake и Conectiva.\nSlackware\nОдин из старейших дистрибутивов, отличается консервативным подходом в разработке и использовании.\nGentoo\nДистрибутив, собираемый из исходных кодов. Позволяет очень гибко настраивать конечную систему и оптимизировать производительность, поэтому часто называет себя мета-дистрибутивом. Ориентирован на экспертов и опытных пользователей.\nArchlinux\nОриентированный на применение самых последних версий программ и постоянно обновляемый, поддерживающий одинаково как бинарную, так и установку из исходных кодов и построенный на философии простоты «KISS» («Keep it simple, stupid» / «Не усложняй»), этот дистрибутив ориентирован на компетентных пользователей, которые хотят иметь всю силу и модифицируемость Linux, но не в жертву времени обслуживания.\nПомимо перечисленных, существует множество других дистрибутивов, как базирующихся на перечисленных, так и созданных с нуля и зачастую предназначенных для выполнения ограниченного количества задач.\nКаждый из них имеет свою концепцию, свой набор пакетов, свои достоинства и недостатки. Ни один не может удовлетворить всех пользователей, а потому рядом с\n       \nлидерами благополучно существуют другие фирмы и объединения программистов, предлагающие свои решения, свои дистрибутивы, свои услуги. Существует множество LiveCD, построенных на основе GNU/Linux, например, Knoppix. LiveCD позволяет запускать GNU/Linux непосредственно с компакт-диска, без установки на жѐсткий диск. Большинство крупных дистрибутивов, включая Ubuntu, могут быть использованы как LiveCD.\nДля желающих досконально разобраться с GNU/Linux подойдѐт любой из дистрибутивов, однако довольно часто для этой цели используются так называемые «source-based» дистрибутивы, то есть предполагающие самостоятельную сборку всех компонентов из исходных кодов, такие как LFS, Gentoo или CRUX.\nПрименение\nОбласть распространения Linux огромна, гораздо больше чем у вcех других операционных систем. Кроме того, что Linux прекрасно работает на обычных домашних и рабочих компьютерах и серверах, существуют адаптации Linux к большинству современных процессоров, что позволяет использовать системы с ядром Linux в сетевом оборудовании, домашней «умной» технике, роботах, мобильных телефонах, различных портативных устройствах и другом оборудовании, поддерживающем программируемые операции.\nВ конечном счѐте столь широкий круг поддерживаемых устройств означает превосходную переносимость программ. Например, одно и то же приложение зачастую можно запустить с минимальными усилиями и на обычном компьютере, и на мобильном телефоне на базе Linux. Для примера: Windows и еѐ младший брат Windows Mobile являются полностью несовместимыми платформами.\nОтдельно хотелось бы отметить одну особенную группу дистрибутивов – Puppy Linux. Puppy тоже можно назвать родительским, так как в его основе лежит не один из вышеперечисленных долгожителей, а достаточно интересные идеи. На базе Puppy создано немало мини-дистрибутивов, есть и локализованная отечественная версия – PuppyRus Linux. Это отдельная ветка Linux, стоящая особняком. Дистрибутивы достаточно молоды, а сообщество малочисленно (по сравнению с остальными дистрибутивами), но я считаю, что у этой вариации есть большие преимущества перед прочими дистрибутивами, если вам хочется лѐгкости, простоты и мобильности.\nНе секрет, что Linux – это своего рода конструктор. Много чего может не работать из коробки, а привыкшим к Windows пользователям при любых системных ошибках станет очень некомфортно. Поэтому данные мобильные мини-дистрибутивы очень хорошо подходят для первого знакомства. Они нетребовательны к железу, работают со сменных носителей, а переустановка системы займѐт 5 минут и по сути является просто копированием файла + перезагрузка ПК.\n ",
    "ЛЕКЦИЯ No2\n«Подсистемы обеспечения безопасности ОС Linux» по дисциплине\n«Основы администрирования программно-аппаратных комплексов под управлением ОС Linux»\n1.Обзор элементов обеспечения безопасности функционирования ОС Linux\nСуществует расхожее мнение о том, что Linux характеризуется слабой безопасностью. Но это в корне не верно. Linux - детище глобальной сети Internet и именно поэтому безопасности при ее разработке всегда уделялось огромное внимание. Не случайно в вопросах защищенности Linux всегда выгодно отличалась от многих современных ОС, втом числе многих коммерческих версий Unix.\nВ настоящее время существуют два основных подхода, используемых для обеспечения безопасности ОС: слабо защищенная ОС дополняется для усиления защитным экраном (продукты Microsoft), или средства защиты интегрируются на уровне ядра системы(Linux). При создании системы защиты для любой ОС нужно четко понимать, что реализовать абсолютно безопасную компьютерную систему невозможно. Можно создать лишь дополнительные препятствия для предотвращения попыток проникновения в систему.\nОбъем и качество реализованных средств защиты зависят от области использования Linux. Кроме того, необходимо брать в расчет, что с ростом количества установленных средств защиты система становится все более враждебной для пользователя. Поэтому главная задача при создании системы защиты состоит в поиске точки баланса, которая будет приемлема для политики управления Linux-системой.\nПри использовании системы защиты необходимо придерживаться следующих принципов: 1)постоянный контроль активности в системе с помощью системного журнала, 2)своевременная установка обновлений (а также текущих версий программного обеспечения, в которых имеются заплатки для обнаруженных в процессе эксплуатации уязвимостей). Вомногих случаях этого более чем достаточно для обеспечения должного уровня безопасности.\nДля того чтобы оценить эффективность системы защиты ОС Linux, необходимо понимание того, какие имннно угрозы могут быть реализованы злоумышленниками на уровне ОС в той или иной конкретной ситуации.\nАтаки на уровне ОС\nНа уровне ОС происходит большое количество атак. Это объясняется очень просто: взломав защиту ОС, злоумышленник может получить доступ к ресурсам как отдельной системы, так и сети.\nСуществует мнение, что самые эффективные атаки на ОС организуются с помощью сложнейших средств, использующих последние достижения науки и техники, а хакер должен быть программистом высочайшей квалификации. Это не совсем так. Однако искусство хакера состоит отнюдь не в том, чтобы разрушать любую компьютерную защиту. Достаточно найти слабое место в конкретной защитной системе и с максимальной выгодой для себя\n \nвоспользоваться им. При этом простейшие методы атаки оказываются ничуть не хуже самых изощренных, поскольку простой алгоритм реже порождает ошибки и сбои.\nУспех реализации вредоносного воздействия на практике в значительной степени зависит от архитектуры и конфигурации конкретной ОС - объекта атаки.\n2. Характеристика элементов обеспечения безопасности функционирования ОС Linux\nРассмотрим, какие механизмы противодействия различным атакам применяются в ОС Linux.\nТрадиционные способы защиты, используемые в Linux\nТрадиционные способы защиты ОС в основном связаны с физической безопасностью. Физическая безопасность- это первый уровень безопасности, который необходимо обеспечить для любой компьютерной системы. Причем к очевидным методам обеспечения физической безопасности относятся замки на дверях, кабели в коробах, закрытые ящики столов, средства видеонаблюдения и т. п. Для усиления этих проверенных временем мероприятий можно использовать также компьютерные замки различных конструкций, основное назначение которых сводится к следующему:\n- предотвращение хищения компьютера и его комплектующих;\n- предотвращение возможности перезагрузки компьютера посторонним, а также использования собственных дисководов или иного периферийного оборудования;\n- прерывание работы компьютера при вскрытии корпуса;\n- блокировка работы с клавиатурой и мышью.\nПри установке Linux-системы необходимо внимательно ознакомиться сдокументацией на BIOS - ближайший к аппаратным средствам слой ПО, и многие загрузчики Linux используют функции BIOS для защиты от перезагрузки системы злоумышленниками, а также манипулирования Linux-системой.\nНекоторые загрузчики Linux позволяют установить пароль, запрашиваемый при загрузке системы. Так, при работе с LILO (Linux Loader) можно использовать параметры (позволяет установить пароль для начальной загрузки) и (разрешает загрузку после указания определенных опций в ответ на запрос LILO).\nПериодически появляется необходимость отлучаться от компьютера. В таких ситуациях полезно заблокировать консоль, чтобы исключить возможность ознакомления с вашим именем и результатами работы. Для решения этой задачи в Linux используются программы xlock и vlock. С помощью xlock блокируется доступ для X дисплея (для восстановления доступа необходимо ввести пароль). В отличие от xlock vlock позволяет заблокировать работу отдельных (или всех) виртуальных консолей Linux-машины. При использовании этих полезных программ нужно помнить, что они не защищают от перезагрузки или других способов прерывания работы системы.\nБольшинство методов, спомощью которых злоумышленник может получить доступ к ресурсам, требуют перезагрузки или выключения питания машины. В связи с этим нужно очень серьезно относиться к любым признакам взлома как на корпусе, так и внутри компьютера, фиксировать ианализировать все странности инесоответствия всистемном журнале. При этом нужно исходить из того, что любой взломщик всегда пытается скрыть следы своего присутствия. Для просмотра системного журнала обычно достаточно проверить содержимое файлов syslog, messages, faillog и maillog в каталоге /var/log. Полезно также\n \nустановить скрипт ротации журнальных файлов или демона, который сохраняет журналы на заданную глубину (в последних дистрибутивах Red Hat для этого используется пакет logrotate).\nНесколько слов о локальной безопасности Linux-систем. Она обычно связана с двумя моментами: защита от локальных пользователей и защита от администратора системы. Не секрет, что получение доступа к счетам локальных пользователей - это первая задача, которую ставит перед собой злоумышленник, пытаясь проникнуть в систему. Если надежные средства локальной защиты отсутствуют, то, используя ошибки вОС и/или неверно сконфигурированные службы, злоумышленник может легко изменить полномочия в сторону увеличения, что чревато тяжелыми последствиями. Общие правила, которые необходимо соблюдать для повышения локальной защиты состоят вследующем: предоставление минимально необходимого уровня привилегий; контроль за регистрацией всех пользователей; своевременное изъятие счетов пользователей. Нужно постоянно помнить отом, что неконтролируемые счета - идеальный плацдарм для проникновения в систему.\nНеобдуманные и некорректные действия администратора также представляют серьезную опасность для Linux-системы. Поэтому администратор всегда должен помнить о том, что постоянная работа со счетом суперпользователя (root) - очень опасный стиль (в качестве компромисса лучше использовать команды su или sudo). Права суперпользователя необходимо использовать только для решения специфических задач, в остальных случаях рекомендуется использовать обычный пользовательский счет. В дополнение к этому при выполнении сложных команд администратор должен использовать такие режимы, которые не приведут к потере данных. И последнее: администратор не должен забывать о существовании троянов, так как программы этого типа при запуске с правами суперпользователя могут внести серьезные нарушения в систему защиты. Для исключения этого необходимо тщательно контролировать процесс установки программ на компьютере (в частности, дистрибутив RedHat предусматривает использование цифровых подписей md5 и pgp для проверки целостности rmp-файлов во время установки системы).\nЗащита Linux с помощью паролей\nАнализ рисков на уровне ОС показывает, что наибольшую опасность представляют действия злоумышленников, связанные с кражей или подбором паролей. Защита паролей поэтому должна занимать ведущее место в системе защиты любой ОС.\nЗащита паролей - область, в которой Linux существенно отличается от многих коммерческих версий Unix и других ОС, причем в лучшую сторону.\nВ большинстве современных реализаций Linux программа passwd не позволяет пользователю вводить легко разгадываемые пароли путем предупреждения о потенциальной опасности пароля (ввод пароля при этом, к сожалению, не блокируется). Для проверки устойчивости ансамбля конкретного пароля к подбору существует немало программ. Причем используются они с успехом как системными администраторами, так и взломщиками. Наиболее распространенные представители этого класса программ - Crack и John Ripper. Стоит отметить, что эти программы требуют дополнительного процессорного времени, но эта потеря вполне оправдана- замена слабых паролей значительно снижает вероятность проникновения в систему.\nLinux обеспечивает защиту паролей с помощью трех основных механизмов:\n1. Шифрование паролей.\n \n2. Механизм теневых паролей.\n3. Механизм подключаемых модулей аутентификации PAM (Pluggable Authentication Modules).\nКратко рассмотрим суть этих механизмов.\nШифрование паролей.\nВ Linux для шифрования паролей традиционно используется алгоритм DES. Зашифрованный пароль обычно помещается в файл /etc/passwd. При попытке пользователя зарегистрироваться в системе введенный им пароль шифруется и затем сравнивается с записью в парольном файле. При совпадении система разрешает доступ. Впрограмме шифрования паролей используется однонаправленное шифрование (достигается за счет того, что ключом для шифрования пароля является сам пароль). К сожалению, в настоящее время алгоритм DES уязвим к атаке со стороны мощных компьютеров (использование прямого перебора или подбора в большинстве случаев приводит к отгадыванию паролей). Поэтому для Linux были разработаны дополнительно к шифрованию еще два мощных механизма защиты.\nМеханизм <теневых паролей>.\nСуть этого механизма проста: парольный файл, даже зашифрованный, доступен только системному администратору. Для этого он помещается в файл /etc/shadow, права на чтение которого принадлежат только суперпользователям. Для реализации подобной схемы защиты в Linux используется набор программных средств Shadow Suite. В большинстве дистрибутивов Linux механизм теневых паролей поумолчанию незадействован (кроме, пожалуй, RedHat). Ноименно Linux выгодно отличает наличие новейшего механизма, с помощью которого можно легко организовать мощную систему защиты. Это технология подключаемых модулей аутентификации ( PAM ).\nМеханизм PAM.\nМодули безопасности - это набор открытых библиотек, предназначенных для выполнения набора функций (ввод пароля или проверка его подлинности). Любая программа, использующая систему защиты, может использовать PAM-модули и обеспечить в результате любой уровень безопасности. При использовании этого новейшего механизма программист концентрирует свое внимание на решении прикладной задачи. Ему не надо изобретать систему защиты, при этом также гарантируется, что он в этой системе не наставит <дыр>. Технология PAM позволяет реализовать некоторые новые возможности при создании системы защиты: вмодулях безопасности применяются нестандартные процедуры шифрования (MD5 и им подобные); установка ограничений на использование пользователями системных ресурсов (предотвращение инициализации атак типа <Отказ в обслуживании>); установка разрешения отдельным пользователям регистрации только вфиксированные промежутки времени и только с определенных терминалов или узлов.\nДополнительные средства защиты Linux\nЗащита данных.\nДля контроля целостности данных, которая может быть нарушена врезультате как локальных, так и сетевых атак, в Linux используется пакет Tripwire. При запуске он вычисляет контрольные суммы всех основных двоичных и конфигурационных файлов, после чего сравнивает их с эталонными значениями, хранящимися в специальной базе данных. В результате администратор имеет возможность контролировать любые изменения в системе. Целесообразно разместить Tripwire назакрытом от записи гибком магнитном диске и ежедневно запускать.\n     \nБезусловно, что для повышения конфиденциальности полезно хранить данные на дисках в зашифрованном виде. Для обеспечения сквозного шифрования всей файловой системы в Linux используются криптографические файловые системы CFS (Cryptographic File System) и TCFS (Transparent Cryptographic File System).\nЗащита дисплеев.\nЗащита графического дисплея - важный момент в обеспечении безопасности системы. Она направлена на исключение возможности перехвата пароля, ознакомления с информацией, выводимой на экран, и т. п. Для организации этой защиты в Linux предусмотрены следующие средства:\n- программа xhost (позволяет указать, каким узлам разрешен доступ к вашему дисплею);\n- регистрация с использованием xdm (x display manager) - для каждого пользователя генерируется 128-битный ключ (cookie);\n- организация обмена с помощью защищенной оболочки ssh (secure shell) - в сети исключается поток незашифрованных данных.\nДополнительно к этому для организации контроля доступа к видеоподсистеме компьютера врамках Linux разработан проект GGI (Generic Graphics Interface). Идея GGI состоит впереносе части кода, обслуживающего видеоадаптеры, вядро Linux. Спомощью GGI практически исключается возможность запуска на вашей консоли фальшивых программ регистрации.\nСетевая защита. По мере развития сетевых технологий вопросы безопасности при работе в сети становятся все более актуальными. Практика показывает, что зачастую именно сетевые атаки проходят наиболее успешно. Поэтому в современных ОС сетевой защите уделяется очень серьезное внимание. В Linux для обеспечения сетевой безопасности тоже применяется несколько эффективных средств:\n- защищенная оболочка ssh для предотвращения атак, в которых для получения паролей используются анализаторы протоколов;\n- программы tcp_wrapper для ограничения доступа к различным службам вашего компьютера; - сетевые сканеры для выявления уязвимых мест компьютера;\n- демон tcpd для обнаружения попыток сканирования портов со стороны злоумышленников (в дополнение к этому средству полезно регулярно просматривать файлы системного журнала); - система шифрования PGP (Pretty Good Privacy);\n- программа stelnet (защищенная версия хорошо известной программы telnet);\n- программа qmail (защищенная доставка электронной почты);\n- программа ipfwadm для настройки межсетевых экранов (firewall);\n- режим проверки паролей входных соединений для систем, разрешающих подключение по внешним коммутируемым линиям связи или локальной сети.\nОтрадно отметить, что многие из перечисленных средств включены в состав последних дистрибутивов Linux.\nЗаключение\nLinux - это уникальная ОС, построенная на основе ОС Unix с двадцатипятилетней историей. Насегодняшний день это, пожалуй, единственный пример столь масштабного и плодотворного сотрудничества специалистов всего мира, объединенных сетью Internet. Именно поэтому любая подсистема этой ОС, в том числе и подсистема защиты, представляет большой практический интерес и содержит много особенностей, некоторые из них не нашли свое достаточное отражение в данной статье.\n  \nВ рамках Linux разработана мощная интегрированная система защиты, способная обеспечить безопасность систем, работающих в различных условиях (от домашних компьютеров до банковских систем). Благодаря самому духу разработки Linux различные заплатки в системе защиты появляются гораздо быстрее, чем это происходит в коммерческих ОС, и это делает Linux идеальной платформой для построения надежных вычислительных систем.\n",
    "ЛЕКЦИЯ No3\n«Подсистемы аудита в Linux.» по дисциплине\n«Основы администрирования программно-аппаратных комплексов под управлением ОС Linux»\n1.Основные подсистемы аудита в Linux. 2.Конфигурирование основных подсистем аудита в Linux\n1.Основные подсистемы аудита в Linux.\nОдним из инструментов, позволяющих повысить уровень безопасности в Linux, является подсистема аудита. C еѐ помощью можно получить подробную информацию обо всех системных событиях. Она не обеспечивает никакой дополнительной защиты, но предоставляет подробную информацию о нарушениях безопасности, на основании которой можно принять конкретные меры. Особенности работы с подсистемой аудита мы рассмотрим в этой статье.\nПодсистема аудита: архитектура и принцип работы\nПодсистема аудита была добавлена в ядро Linux начиная с версии 2.6. Она предназначена для отслеживания критичных с точки зрения безопасности системных событий. В качестве примеров таких событий можно привести следующие (список далеко не полный):\nзапуск и завершение работы системы;\nчтение, запись и изменение прав доступа к файлам; инициация сетевых соединений;\nпопытки неудачной авторизации в системе; изменение сетевых настроек;\nизменение информации о пользователях и группах; запуск и остановка приложений;\nвыполнение системных вызовов.\n\nНи одно из названных событий не может произойти без использования системных вызовов ядра. Чтобы их отслеживать, достаточно просто перехватывать соответствующие системные вызовы. Именно это и делает подсистема аудита: Получив вызов от приложения в пространстве пользователя, подсистема аудита пропускает его через один из следующих фильтров: user, task или exit (более подробно о них речь пойдѐт ниже). После этого вызов пропускается через фильтр exclude, который исходя из правил аудита передаѐт его демону auditd для дальнейшей обработки. Такая простая схема позволяет вполне эффективно отслеживать любой аспект работы ОС, а в случае компрометации системы выявлять подозрительные действия и определять их причину.\nУстановка\nЧтобы начать работать с подсистемой аудита, нужно установить пакет auditd:\n$ sudo apt-get install auditd\nВ cостав этого пакета входят демон auditd и несколько вспомогательных утилит:\nauditctl — утилита для управления демоном auditd; позволяет получать информацию о текущем состоянии подсистемы аудита, а также добавлять и удалять правила;\nautrace — утилита для аудита событий, порождаемых процессами (работает по тому же принципу, что и strace);\nausearch — утилита для поиска событий в журнальных файлах; aureport — утилита для генерации отчѐтов о работе системы аудита.\n2.Конфигурирование основных подсистем аудита в Linux\nНастройки подсистемы аудита хранятся в конфигурационном файле etc/audit/auditd.conf. Он содержит в числе прочих следующие параметры:\nlog_file — файл, в котором будут храниться логи подсистемы аудита;\nlog_format — формат, в котором будет сохранены логи;\nfreq — максимальное число записей протокола, которые могут храниться в буфере;\nflush — режим синхронизации буфера с диском (none — ничего не делать, incremental — переносить данные из буфера на диск с частотой, указанной в значении параметра freq; data — синхронизировать немедленно, sync — синхронизировать как данные, так и метаданные файла при записи на диск);\nmax_log_file — максимальный размер файла лога в мегабайтах;\n\nmax_log_file_action — действие при превышении максимального размера файла лога;\nspace_left — минимум свободного пространства в мегабайтах, по достижении которого должно быть осуществлено действие, указанное в следующем параметре;\nspace_left_admin — указывает, что делать, когда на диске недостаточно свободного места (ignore — ничего не делать; syslog — отправлять в syslog, email — отправлять уведомление по почте; suspend — прекратить запись логов на диск; single — перейти в однопользовательский режим; halt — выключить машину)\ndisk_full_action — действие, которое нужно осуществить при переполнении диска (этот параметр может принимать те же значения, что и space_left_admin).\nСоздание правил\nДля добавления и настройки правил используется команда auditctl. Вот список еѐ опций: -l — вывести список имеющихся правил;\n-а — добавить новое правило;\n-d — удалить правило из списка;\n-D — удалить все имеющиеся правила.\nЧтобы создать новое правило, нужно выполнить команду вида:\n$ auditctl -a , -S -F\nСначала после опции -а указывается список, в который нужно добавить правило. Всего существует 5 таких списков:\ntask — события, связанные с созданием новых процессов;\nentry — события, которые имеют место при входе в системный вызов;\nexit — события, которые имеют место при выходе из системного вызова;\nuser — события, использующие параметры пользовательского пространства;\nexclude — используется для исключения\nЗатем указывается, что нужно делать после наступления события. Здесь возможны два варианта: always (события будут записываться в журнал) и never (не будут). После опции -S идѐт имя системного вызова, при котором событие нужно перехватить (open, close и т.п.). После опции -F указываются дополнительные параметры фильтрации. Например, если нам требуется вести аудит обращений к файлам из каталога /etc, правило будет выглядеть так:\nauditctl -a exit,always -S open -F path =/etc/\nМожно установить и дополнительный фильтр:\n$ auditctl -a exit,always -S open -F path =/etc/ -F perm = aw\nАббревиатура aw означает следующее: а — изменение атрибута (attribute change), w —\nсобытий.\n\nзапись (write). Формулировка perm = aw указывает, что для директории /etc нужно отслеживать все факты изменения атрибутов (а — attribute change) и w (w — write).\nПри настройке слежения за отдельными файлами можно опустить опцию -S, например:\n$ auditctl -a exit,always -F path =/etc/ -F perm = aw\nФайлы правил\nПравила можно не только задавать через командную строку, но и прописывать в файле etc/audit/audit.rules.\nНачинается этот файл с так называемых метаправил, в которых задаются общие настройки журналирования:\n# удаляем все ранее созданные правила\n-D\n# задаѐм количество буферов, в которых будут храниться сообщения\n-b 320\n# указываем, что делать в критической ситуации (например, при переполнении буферов): 0 - ничего не делать; 1 - отправлять сообщение в dmesg, 2 - отправлять ядро в панику\n-f1\nДалее следуют пользовательские правила. Их синтаксис предельно прост: достаточно просто перечислить соответствующие опции команды auditctl. Рассмотрим пример типового файла правил:\n# отслеживать системные вызовы unlink () и rmdir()\n-a exit,always -S unlink -S rmdir\n# отслеживать системные вызовы open () от пользователя с UID 1001\n-a exit,always -S open -F loginuid=1001\n# отслеживать доступ к файлам паролей и групп и попытки их изменения:\n-w /etc/group -p wa\n-w /etc/passwd -p wa\n-w /etc/shadow -p wa\n-w /etc/sudoers -p wa\n# отслеживать доступ к следующей директории: -w /etc/my_directory -p r\n# закрыть доступ к конфигурационному файлу для предотвращения изменений -e 2\nИзменения конфигурации вступят в силу после перезапуска демона auditd:\n$ sudo service auditd restart\nАнализ журнальных файлов: утилита aureport\nВсе журнальные файлы сохраняются в директории /var/log/audit в машиночитаемом формате. Их можно сделать человекопонятными c помощью утилиты aureport. Если ввести команду aureport без аргументов, мы увидим общую системную статистику (количество пользователей системы, общее количество системных вызовов, число открытых терминалов и т.п.):\n$ sudo aureport\n\nОна не имеет особой практической ценности. Гораздо больший интерес представляют специализированные отчѐты. Вот так, например, можно просмотреть информацию обо всех системных вызовах:\n$ sudo aureport -s\nВоспользовавшись опцией -au (или ––auth), можно просмотреть информацию обо всех попытках входа в систему:\n$ sudo aureport -au\nВ аureport поддерживается фильтрация по дате и времени: $ sudo aureport -s --start 07/31/15 12:00 --end 07/31/15 13:00\nМожно указывать как конкретные время и дату, так и специальные человекопонятные конструкции:\nnow — текущий момент;\nyesterday — вчерашнее сутки;\nrecent — 10 минут назад;\nthis-week (или this-month, this-year) — текущая неделя (месяц, год).\nС помощью aureport можно просмотреть информацию о действиях любого пользователя системы. Для этого нужно сначала узнать id этого пользователя:\n$ id user\nuid=1000(user) gid=1000(andrei) groups=1000(andrei),27(sudo)\nи затем выполнить следующую команду:\n$ sudo ausearch -ui 1000 --interpret\nAusearch: поиск и анализ событий\nДля просмотра детальной информации о событии используется утилита ausearch: $ sudo ausearch -a\nВывод приведѐнной выше команды выглядит так:\ntype=SYSCALL msg=audit(1364481363.243:24287): arch=c000003e syscall=2 success=no exit=-13 a0=7fffd19c5592 a1=0 a2=7fffd19c4b50 a3=a items=1 ppid=2686 pid=3538 auid=500 uid=500 gid=500 euid=500 suid=500 fsuid=500 egid=500 sgid=500 fsgid=500 tty=pts0 ses=1 comm=\"cat\" exe=\"/bin/cat\" subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=\"sshd_config\"\nРассмотрим его структуру более подробно. В поле type указывается тип записи; type = syscall означает, что запись была сделана после выполнения системного вызова. В поле msg указано время события в формате Unix Timestamp и его уникальный идентификационный номер.\nВ поле arch содержится информация об используемой архитектуре системы (c000003e означает x86_84), представленная в закодированном шестнадцатеричном формате. Чтобы\n\nона выводилась в человекочитаемом виде, можно воспользоваться опцией -i или –– interpret.\nВ поле syscall указан тип системного вызова — в нашем случае это 2, то есть вызов open. Параметр success сообщает, был ли вызов обработан успешно или нет. В нашем примере вызов был обработан неудачно (success = no).\nДля каждого вызова в отчѐте также перечисляются индивидуальные параметры; более подробно о них можно почитать в официальном руководстве. Вывести на консоль информацию о любом параметре в человекочитаемой форме можно получить при помощи упомянутой выше опции -i или ––interpret, например:\n$ sudo ausearch --interpet --exit -13\nОпция -sc позволяет включать в список события, относящиеся к указанному системному вызову, например:\n$ sudo ausearch -sc ptrace\nОпция -ui служит для поиска событий по идентификатору пользователя:\n$ ausearch -ui 33\nПоиск по именам демонов осуществляется с помощью опции -tm:\n$ ausearch -x -tm cron\nДля поиска нужных событий можно также использовать ключи, например: $ sudo auditctl -k root-actions\nПриведѐнная команда выведет список всех действий, совершѐнных от имени root- пользователя.\nПоддерживается также фильтрация по дате и времени, аналогичная той, что была описана выше.\nВывести список событий, завершившихся неудачно, можно с помощью опции ––failed. Анализ процессов с помощью утилиты autrace В некоторых случаях бывает полезным получить информацию о событиях, связанных с одним конкретным процессом. Для этой цели можно воспользоваться утилитой autrace. Предположим, нам нужно отследить процесс date и узнать, какие системные вызовы и файлы он использует. Выполним команду:\n$ sudo autrace /bin/date\nНа консоли появится следующий текст:\n\nWaiting to execute: /bin/date\nMon Aug 31 17:06:32 MSK 2015\nCleaning up...\nTrace complete. You can locate the records with 'ausearch -i -p 29234'\nОбратим внимание на последнюю строку вывода: в ней указана команда, с помощью которой можно получить более подробную информацию. Выполним эту команду и передадим вывод утилите aureport, которая преобразует его в человекочитаемый формат:\n$ sudo ausearch -p 29215 --raw | aureport -f -i\nЦентрализованное хранение логов\nДля отправки логов подсистемы аудита в централизованное хранилище используется плагин audisp-remote. Он входит в пакет audisp-plugins, который нужно устанавливать дополнительно:\n$ sudo apt-get install audisp-plugins\nКонфигурационные файлы всех плагинов хранятся в директории /etc/audisp/plugins.d.\nНастройки удалѐнного логгирования прописываются в конфигурационном файле /etc/audisp/plugins.d/audisp-remote.conf. По умолчанию этот файл выглядит так:\nactive = no\ndirection = out\npath = /sbin/audisp-remote type = always\n#args =\nformat = string\nЧтобы активировать отправку логов в удалѐнное хранилище, заменим значение параметра active на yes. Затем откроем файл etc/audisp/audisp-remote.conf и в качестве значения параметра remote_server укажем буквенный или IP-адрес cервера, на котором будут храниться логи.\nЧтобы принимать логи с удалѐнных хостов и сохранять их на сервере, в файле /etc/audit/auditd.conf нужно прописать следующие параметры:\ntcp_listen_port = 60\ntcp_listen_queue = 5\ntcp_max_per_addr = 1\n##tcp_client_ports = 1024-65535 #optional tcp_client_max_idle = 0\n",
    "ЛЕКЦИЯ No4\n«Подсистемы журналирования и протоколирования Linux.» по дисциплине\n«Основы администрирования программно-аппаратных комплексов под управлением ОС Linux»\n1. Основные подсистемы журналирования и протоколирования Linux\nОдним из наиболее важных аспектов в управлении любой системой - контроль за системными событиями. Linux предлагает необычный метод журналирования, а также позволяет конфигурировать составные части журналов.\nВ Linux журналы представляют собой обычный текст, так что вы можете исследовать и читать их, не применяя специальных средств. Вы также можете написать скрипт для просмотра журналов и автоматического выполнения каких-либо функций на основе их содержимого. Linux-журналы хранятся в каталоге /var/log. Здесь содержится несколько файлов, которые поддерживаются системой. Другие сервисы и программы также могут размещать здесь свои log-файлы. Большинство журналов доступны для чтения только суперпользователю root, но это можно легко изменить, скорректировав права доступа к файлам. /var/log/messages Журнал сообщений -- основной системный log- файл. Он содержит сообщения о ходе загрузки системы, а также другие сообщения о статусе работающей системы. В этом файле накапливаются сообщения об ошибках ввода/вывода (IO), проблемах с сетью и другие сообщения о системных ошибках. Кроме того, здесь хранится и другая информация, например, о том, в какое время какой-нибудь пользователь стал root'ом. Если запущен какой-либо сервис, например, DHCP-сервер, в этом файле вы можете наблюдать за его деятельностью. С изучения файла /var/log/messages обычно начинают выявление и устранение неполадок.\n/var/log/XFree86.0.log Этот журнал содержит информацию о последнем запуске сервера Xwindow Xfree86. В случае возникновения проблем с запуском графической сессии в этом файле обычно можно найти причину неудачи. Другие журналы В каталоге /var/log могут быть и другие log-файлы в зависимости от того, какой дистрибутив Linux вы используете и какие сервисы и приложения запущены. Например, они могут быть связаны с запуском почтового сервера, распределением ресурсов, автоматическим выполнением задач и т.д. Rotate В каталоге /var/log вы можете видеть несколько файлов, имена которых оканчиваются цифрой. Это \"rotated\" архивы. Log-файлы могут быть довольно большими и громоздкими. В Linux имеется команда для ротации этих файлов, за счет чего текущая информация не смешивается с устаревшими, уже не нужными\n\nданными. Команда logrotate обычно запускается автоматически через определенные промежутки времени, но ее можно запустить и вручную. Команда logrotate берет текущую версию log-файла и добавляет в конец имени файла \".1\". Затем все предыдущие такие файлы нумеруются последовательно: \".2,\" \".3,\" и так далее. Чем больше число в конце имени файла, тем файл старше. Вы можете сконфигурировать автоматический режим работы logrotate, отредактировав файл /etc/logrotate.conf.\nУзнайте больше о команде logrotate при помощи man logrotate.\nСредства работы с журналами\nДля работы с log-файлами можно использовать любой инструмент работы с текстом. Здесь описаны некоторые наиболее полезные инструменты.\nDmesg\nДля беглого обзора журнала загрузки с целью просмотра сообщений о последней загрузке системы воспользуйтесь командой dmesg. Как правило, она выдает большое количество текста, так что вы скорее всего захотите воспользоваться конвейером (pipe). dmesg | more Команда, представленная выше, будет осуществлять постраничный вывод сообщений о ходе загрузки. tailУ вас может возникнуть желание следить за log-файлом в ходе выполнения каких-то действий. Команда tail предназначена для просмотра последних нескольких строк текстового файла. Если добавить опцию -f, tail продолжит показывать новые строки файла по мере их формирования.\ntail -f /var/log/messages\nКоманда, представленная выше, покажет последние десять строк файла /var/log/messages, затем продолжит следить за файлом и будет выдавать сообщения о новых действиях. Чтобы остановить команду tail -f, нажмите Ctrl + C для прерывания процесса. moreКоманда more работает так же, как и в DOS. Вы можете открыть с ее помощью файл или перенаправить на нее вывод для постраничного просмотра информации. Например, чтобы показать одну экранную страницу содержимого стартового log-файла Xfree86, введите такую команду: more /var/log/XFree86.0.log\nЗакончив просмотр файла, нажмите \"q\" или [Ctrl]-C. Less\nДругое средство для просмотра файлов -- less. С его помощью можно просматривать содержимое файла и искать нужную информацию.\nless /var/log/messages\n\nКоманда, представленная выше, покажет содержимое файла /var/log/messages. Для выхода нажмите \"q\". Чтобы получить справку об использовании команды less, нажмите \"h\".\nLogger\nУ вас может появиться желание поместить в системный журнал свои собственные сообщения. Вы можете просто добавить сообщение к нужному текстовому файлу, но вам необходимо будет продублировать стиль записи информации. Кроме того, вы должны изменить ваш код, если система журналирования была перенастроена. Команда logger позволяет посылать ваши собственные сообщения в службу журналирования. Используйте ее в скриптах для генерации сообщений о ходе выполнения процесса и об ошибках.\nНастройка системы журналирования\nДля управления журналированием существует два сервиса, или демона, klogd и syslogd. klogd имеет дело только с сообщениями ядра. syslogd имеет дело с другими системными сообщениями, например, касающимися приложений. Вы можете сконфигурировать оба эти сервиса, отредактировав файлы /etc/syslog.conf и /etc/sysconfig/syslog. В сущности, каждое сообщение, выдаваемое программным обеспечением, предоставляет некую информацию для определения, откуда оно поступило и в чем его суть.\nФайл /etc/syslog.conf позволяет установить, что нужно делать с сообщениями определенного типа. Вы можете помещать их в файл сообщений. Вы можете помещать их в файл настроек. Вы можете послать их на удаленный хост, где они будут обработаны в соответствии с конфигурацией его syslogd.\nУдаленное журналирование -- замечательное средство обеспечения безопасности. Размещая журналы на удаленной системе, вы можете закрыть брешь в системе безопасности, заключающуюся в том, что злоумышленник может удалить следы своей деятельности в log-файлах.\nПротоколирование\nВ любой UNIX-подобной системе есть стандартные файлы протоколов (журналов). В них попадают сообщения, генерируемые ядром, системными демонами, утилитами окружения. Эти файлы размещаются в каталоге /var/log . Прикладные программы обычно помещают свои протоколы в подкаталоги этого каталога, например, /var/log/httpd — журналы HTTP-сервера. Точное расположение журнала прикладной программы зависит от ее настройки.\nЗа ведение журналов отвечает система регистрации событий syslog. Она позволяет сортировать сообщения по источникам и степени важности, а также перенаправлять их в\n      \nжурнальные файлы, на консоль или на другой компьютер в сети. Все подсистемы (демоны) и правильно написанные прикладные программы не ведут протоколов самостоятельно, а посылают сообщения в систему регистрации. Дальнейшая судьба этих сообщений зависит от политики системного администратора.\nСистема регистрации состоит из следующих компонент:\n? демон syslogd, принимающий сообщения от других процессов и перенаправляющий их указанным адресатам;\n? библиотечные функции openlog(), syslog(), closelog(), посредством которых процессы общаются с демоном syslogd. Функция syslog() записывает протокольное сообщение в гнездо (сокет) /dev/log , откуда его читает демон syslogd ;\n?команда logger, с помощью которой сообщение демону syslogd может передать командный интерпретатор.\nДемон syslogd запускается инициализационным сценарием в ходе начальной загрузки системы и работает непрерывно. Убедиться в том, что он запущен, можно с помощью команды\n$ ps -ef | grep syslogd | grep -v grep\nПримечание\nПоследняя в этом конвейере команда нужна для того, чтобы отфильтровать из вывода команды grep сведения о самой команде grep.\nЕсли ваша система загружается в стиле System V, то сценарий запуска демона — это\n/etc/rc.d/init.d/syslog . Как обычно, запустить демон самостоятельно вы можете с помощью команды\nа остановить —   .\nАвтоматический запуск системы syslog можно отключить или включить при помощи\nграфического конфигуратора (setup для дистрибутива Red Hal, drakxservices для Mandrake, system-config-services для Fedora Core).\nВ Red Hat-совместимых дистрибутивах демон syslogd устанавливается из пакета sysklogd, в состав которого входит также демон klogd, принимающий сообщения ядра и отправляющий их на обработку демону syslogd.\nКак и всякий демон, syslogd управляется конфигурационным файлом. По умолчанию это\n              /etc/rc.d/init.d/syslog start\n  файл\nsyslogd с ключом\n, однако ничто не мешает назвать его как угодно, а потом запускать . Об остальных немногочисленных ключах можно\n/etc/rc.d/init.d/syslog.stop\n   /etc/syslog.conf\n   -f /path/to/config.file\n   узнать но команде\nПо сигналу HUP демон закрывает все журнальные файлы, перечитывает конфигурационный файл и возобновляет процесс протоколирования. Чтобы изменения в конфигурационном файле вступили в силу, нужно послать демону syslogd сигнал HUP. Например, так:\n$ kill -HUP `cat /var/run/syslogd.pid`\nman syslogd\n.\n    ",
    "ЛЕКЦИЯ No5\n«Основные команды управления Linux» по дисциплине\n«Основы администрирования программно-аппаратных комплексов под управлением ОС Linux»\nСистемная информация\nотобразить архитектуру компьютера:\narch\nотобразить используемую версию ядра\nuname -r\nпоказать аппаратные системные компоненты — (SMBIOS / DMI)\ndmidecode -q\nвывести характеристики жесткого диска\nhdparm -i /dev/hda\nотобразить информацию о процессоре\ncat /proc/cpuinfo показать прерывания\ncat /proc/interrupts\nпроверить использование памяти\ncat /proc/meminfo показать файл(ы) подкачки\ncat /proc/swaps вывести версию ядра\ncat /proc/version\nпоказать сетевые интерфейсы и статистику по ним\ncat /proc/net/dev\nотобразить смонтированные файловые системы\ncat /proc/mounts\nпоказать в виде дерева PCI устройства\nlspci -tv\nпоказать в виде дерева USB устройства\nlsusb -tv\nвывести системную дату\ndate\nвывести таблицу-календарь 2011-го года\ncal 2007\nустановить системные дату и время ММДДЧЧммГГГГ.СС\ndate 041217002007.00*\nсохранить системное время в BIOS\nclock –w Остановка системы\n\nостановить систему shutdown -h\nзапланировать остановку системы на указанное время shutdown -h hours:minutes &\nотменить запланированную по расписанию остановку системы shutdown -c\nперезагрузить систему shutdown -r\nвыйти из системы logout\nФайлы и директории\nперейти в cd /home перейти в\ncd .. перейти в\ncd ../.. перейти в\ncd перейти в\ncd ~user перейти в\nдиректорию ‘/home’\nдиректорию уровнем выше\nдиректорию двумя уровнями выше\nдомашнюю директорию\nдомашнюю директорию пользователя user\nдиректорию, в которой находились до перехода в текущую директорию\ncd -\nпоказать текущюю директорию\npwd\nотобразить содержимое текущей директории\nls\nотобразить содержимое текущей директории с добавлением к именам символов, храктеризующих тип\nls -F\nпоказать детализированое представление файлов и директорий в текущей директории\nls -l\nпоказать скрытые файлы и директории в текущей директории\nls -a\nпоказать файлы и директории содержащие в имени цифры\nls *[0-9]*\nпоказать дерево файлов и директорий, начиная от корня (/)\ntree\nсоздать директорию с именем ‘dir1’\nmkdir dir1\nсоздать две директории одновременно\nmkdir dir1 dir2\nсоздать дерево директорий\nmkdir -p /tmp/dir1/dir2 удалить файл с именем ‘file1’\nrm -f file1\n\nудалить директорию с именем ‘dir1’ rmdir dir1\nудалить директорию с именем ‘dir1’ и рекурсивно всѐ еѐ содержимое rm -rf dir1\nудалить две директории и рекурсивно их содержимое rm -rf dir1 dir2\nпереименовать или переместить файл или директорию mv dir1 new_dir\nскопировать файл file1 в файл file2 cp file1 file2\nкопировать все файлы директории dir в текущую директорию cp dir/* .\nкопировать директорию dir1 со всем содержимым в текущую директорию cp -a /tmp/dir1 .\nкопировать директорию dir1 в директорию dir2 cp -a dir1 dir2\nсоздать символическую ссылку на файл или директорию ln -s file1 lnk1*\nсоздать «жѐсткую» (физическую) ссылку на файл или директорию ln file1 lnk1\nмодифицировать дату и время создания файла, при его отсутствии, создать файл с указанными датой и временем (YYMMDDhhmm)\ntouch -t 0712250000 fileditest\nПоиск файлов\nнайти файлы и директории с именем file1. Поиск начать с корня (/)\nfind / -name file1\nнайти файл и директорию принадлежащие пользователю user1. Поиск начать с корня (/)\nfind / -user user1\nнайти все файлы и директории, имена которых оканчиваются на ‘. bin’. Поиск начать с ‘/ home/user1’*\nfind /home/user1 -name \"*.bin\"\nнайти все файлы в ‘/usr/bin’, время последнего обращения к которым более 100 дней\nfind /usr/bin -type f -atime +100\nнайти все файлы в ‘/usr/bin’, созданные или изменѐнные в течении последних 10 дней\nfind /usr/bin -type f -mtime -10\nнайти все файлы и директории, имена которых оканчиваются на ‘.rpm’, и изменить права доступа к ним\nfind / -name *.rpm -exec chmod 755 '{}' \\;\nнайти все файлы и директории, имена которых оканчиваются на ‘.rpm’, игнорируя съѐмные носители, такие как cdrom, floppy и т.п.\nfind / -xdev -name \"*.rpm\"\nнайти все файлы, сожержащие в имени ‘.ps’. Предварительно рекомендуется выполнить команду ‘updatedb’\nlocate \"*.ps\"\nпоказывает размещение бинарных файлов, исходных кодов и руководств, относящихся к файлу ‘halt’\n\nwhereis halt\nотображает полный путь к файлу ‘halt’\nwhich halt\nМонтирование файловых систем\nмонтирует раздел ‘hda2’ в точку монтирования ‘/mnt/hda2’. Убедитесь в наличии директории-точки монтирования ‘/mnt/hda2’\nmount /dev/hda2 /mnt/hda2\nразмонтирует раздел ‘hda2’. Перед выполнением, покиньте ‘/mnt/hda2’\numount /dev/hda2\nпринудительное размонтирование раздела. Применяется в случае, когда раздел занят каким-либо пользователем\nfuser -km /mnt/hda2\nвыполнить размонитрование без занесения информации в /etc/mtab. Полезно когда файл имеет атрибуты «только чтение» или недостаточно места на диске\numount -n /mnt/hda2 монтировать флоппи-диск\nmount /dev/fd0 /mnt/floppy монтировать CD или DVD\nmount /dev/cdrom /mnt/cdrom\nмонтировать CD-R/CD-RW или DVD-R/DVD-RW(+-)\nmount /dev/hdc /mnt/cdrecorder смонтировать ISO-образ\nmount -o loop file.iso /mnt/cdrom\nмонтировать файловую систему Windows FAT32\nmount -t vfat /dev/hda5 /mnt/hda5\nмонтировать сетевую файловую систему Windows (SMB/CIFS)\nmount -t smbfs -o username=user,password=pass //winclient/share /mnt/share\n«монтирует» директорию в директорию (binding). Доступна с версии ядра 2.4.0. Полезна, например, для предоставления содержимого пользовательской директории через ftp при работ е ftp-сервера в «песочнице» (chroot), когда симлинки сделать невозможно. Выполнение данной команды сделает копию содержимого /home/user/prg в /var/ftp/user\nmount -o bind /home/user/prg /var/ftp/user\nДисковое пространство\nинформация о смонтированных разделах с отображением общего, доступного и используемого пространства (Прим.переводчика. ключ -h работает не во всех *nix системах)\ndf -h\nвывести список файлов и директорий рекурсивно с сортировкой по возрастанию размера и осуществлять постраничный просмотр\nls -lSr |more\nвывести размер, занимаемый директорией ‘dir1’ (Прим.переводчика. ключ -h работает не во всех *nix системах)\ndu -sh dir1\nразмер и имена файлов и директорий, с соритровкой по размеру\ndu -sk * | sort -rn\n\nразмер используемого дискового пространства, занимаемое файлами rpm-пакета, с сортировкой по размеру (fedora, redhat и т.п.)\nrpm -q -a --qf '%10t%n' | sort -k1,1n\nразмер используемого дискового пространства, занимаемое файлами deb-пакета, с сортировкой по размеру (ubuntu, debian т.п.)\ndpkg-query -W -f='${Installed-Size;10}t$n' | sort -k1,1n Пользователи и группы\nсоздать новую группу с именем group_name\ngroupadd group_name удалить группу group_name\ngroupdel group_name\nпереименовать группу old_group_name в new_group_name\ngroupmod -n new_group_name old_group_name\nсоздать пользователя user1, назначить ему в качестве домашнего каталога /home/user1, в качестве shell’а /bin/bash, включить его в группу admin и добавить комментарий Nome Cognome\nuseradd -c \"Nome Cognome\" -g admin -d /home/user1 -s /bin/bash user1 создать пользователя user1\nuseradd user1\nудалить пользователя user1 и его домашний каталог\nuserdel -r user1\nизменить атрибуты пользователя\nusermod -c \"User FTP\" -g system -d /ftp/user1 -s /bin/nologin user1 сменить пароль\npasswd\nсменить пароль пользователя user1 (только root)\npasswd user1\nустановить дату окончания действия учѐтной записи пользователя user1\nchage -E 2005-12-31 user1\nпроверить корректность системных файлов учѐтных записей. Проверяются файлы /etc/passwd и /etc/shadow\npwck\nпроверить корректность системных файлов учѐтных записей. Проверяется файл/etc/group\ngrpck\nизменить первичную группу текущего пользователя. Если указать «-», ситуация будет идентичной той, в которой пользователь вышил из системы и снова вошѐл. Если не указывать группу, первичная группа будет назначена из /etc/passwd\nnewgrp [-] group_name\nВыставление/изменение полномочий на файлы\nпросмотр полномочий на файлы и директории в текущей директории\nls -lh\nвывести содержимое директории /tmp и разделить вывод на пять колонок\nls /tmp | pr -T5 -W$COLUMNS\nдобавить полномочия на директорию directory1 ugo(User Group Other)+rwx(Read Write eXecute) — всем полные права. Аналогичное можно сделать таким образом chmod 777 directory1\n\nchmod ugo+rwx directory1\nотобрать у группы и всех остальных все полномочия на директорию directory1\nchmod go-rwx directory1\nназначить владельцем файла file1 пользователя user1\nchown user1 file1\nназначить рекурсивно владельцем директории directory1 пользователя user1\nchown -R user1 directory1\nсменить группу-владельца файла file1 на group1\nchgrp group1 file1\nсменить владельца и группу владельца файла file1\nchown user1:group1 file1\nнайти, начиная от корня, все файлы с выставленным SUID\nfind / -perm -u+s\nназначить SUID-бит файлу /bin/binary_file. Это даѐт возможность любому пользователю запускать на выполнение файл с полномочиями владельца файла\nchmod u+s /bin/binary_file\nснять SUID-бит с файла /bin/binary_file\nchmod u-s /bin/binary_file\nназначить SGID-бит директории /home/public\nchmod g+s /home/public\nснять SGID-бит с директории /home/public\nchmod g-s /home/public\nназначить STIKY-бит директории /home/public. Позволяет удалять файлы только владельцам\nchmod o+t /home/public\nснять STIKY-бит с директории /home/public\nchmod o-t /home/public\nСпециальные атрибуты файлов\nпозволить открывать файл на запись только в режиме добавления\nchattr +a file1\nпозволяет ядру автоматически сжимать/разжимать содержимое файла\nchattr +c file1\nуказавет утилите dump игнорировать данный файл во время выполнения backup’а\nchattr +d file1\nделает файл недоступным для любых изменений: редактирование, удаление, перемещение, создание линков на него\nchattr +i file1\nпозволяет сделать удаление файла безопасным, т.е. выставленный атрибут s говорит о том, что при удалении файла, место, занимаемое файлом на диске заполняется нулями, что предотвращяет возможность восстановления данных\nchattr +s file1\nуказывает, что, при сохранении изменений, будет произведена синхронизация, как при выполнении команды sync\nchattr +S file1\nданный атрибут указывает, что при удалении файла содержимое его будет сохранено и при необходимости пользователь сможет его восстановить\n\nchattr +u file1\nпоказать атрибуты файлов\nlsattr\nАрхивирование и сжатие файлов разжать файл ‘file1.bz2’\nbunzip2 file1.bz2 разжать файл ‘file1.gz’\ngunzip file1.gz сжать файл ‘file1’\ngzip file1 или bzip2 file1\nсжать файл file1 с максимальным сжатием\ngzip -9 file1\nсоздать rar-архив ‘file1.rar’ и включить в него файл test_file\nrar a file1.rar test_file\nсоздать rar-архив ‘file1.rar’ и включить в него file1, file2 и dir1\nrar a file1.rar file1 file2 dir1 распаковать rar-архив\nunrar x file1.rar\nсоздать tar-архив archive.tar, содержащий файл file1\ntar -cvf archive.tar file1\nсоздать tar-архив archive.tar, содержащий файл file1, file2 и dir1\ntar -cvf archive.tar file1 file2 dir1 показать содержимое архива\ntar -tf archive.tar распаковать архив tar -xvf archive.tar\nраспаковать архив в /tmp tar -xvf archive.tar -C /tmp\nсоздать архив и сжать его с помощью bzip2(Прим.переводчика. ключ -j работает не во всех *nix системах)\ntar -cvfj archive.tar.bz2 dir1\nразжать архив и распаковать его(Прим.переводчика. ключ -j работает не во всех *nix системах)\ntar -xvfj archive.tar.bz2\nсоздать архив и сжать его с помощью gzip\ntar -cvfz archive.tar.gz dir1 разжать архив и распаковать его\ntar -xvfz archive.tar.gz создать сжатый zip-архив\nzip file1.zip file1\nсоздать сжатый zip-архив и со включением в него нескольких файлов и/или директорий\nzip -r file1.zip file1 file2 dir1 разжать и распаковать zip-архив\nunzip file1.zip\nRPM пакеты (Fedora, Red Hat и тому подобное) установить пакет с выводом сообщений и прогресс-бара\n\nrpm -ivh package.rpm\nустановить пакет с выводом сообщений и прогресс-бара без контроля зависимостей\nrpm -ivh --nodeps package.rpm\nобновить пакет без изменений конфигурационных файлов, в случае отсутствия пакета, он будет установлен\nrpm -U package.rpm\nобновить пакет только если он установлен\nrpm -F package.rpm удалить пакет\nrpm -e package_name.rpm\nотобразить список всех пакетов, установленных в системе\nrpm -qa\nсреди всех пакетов, установленных в системе, найти пакет содержащий в своѐм имени «httpd»\nrpm -qa | grep httpd\nвывести информацию о конкрентном пакете\nrpm -qi package_name\nотобразить пакеты входящие в группу пакетов\nrpm -qg \"System Environment/Daemons\" вывести список файлов, входящих в пакет\nrpm -ql package_name\nвывести список конфигурационных файлов, входящих в пакет\nrpm -qc package_name\nвывести список пакетов, необходимых для установки конкретного пакета по зависимостям\nrpm -q package_name --whatrequires\nотобразить скрипты, запускаемые при установке/удалении пакета\nrpm -q package_name --scripts вывести историю ревизий пакета\nrpm -q package_name --changelog\nпроверить какому пакету принадлежит указанный файл. Указывать следует полный путь и имя файла\nrpm -qf /etc/httpd/conf/httpd.conf\nотображает список файлов, входящих в пакет, но ещѐ не установленных в систему\nrpm -qp package.rpm -l\nипортировать публичный ключ цифровой подписи\nrpm --import /media/cdrom/RPM-GPG-KEY проверит подпись пакета\nrpm --checksig package.rpm\nпроверить целостность установленного содержимого пакета\nrpm -qa gpg-pubkey\nпроверить размер, полномочия, тип, владельца, группу, MD5-сумму и дату последнего изменеия пакета\nrpm -V package_name\nпроверить содержимое всех пакеты установленные в систему. Выполняйте с осторожностью!\nrpm -Va\n\nпроверить пакет, который ещѐ не установлен в систему rpm -Vp package.rpm\nизвлечь из пакета файлы содержащие в своѐм имени bin rpm2cpio package.rpm | cpio --extract --make-directories *bin*\nустановить пакет, собранный из исходных кодов rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm\nсобрать пакет из исходных кодов rpmbuild --rebuild package_name.src.rpm\nYUM — средство обновления пакетов(Fedora, RedHat и тому подобное) закачать и установать пакет\nyum install package_name\nобновить все пакеты, установленные в систему\nyum update обновить пакет\nyum update package_name удалить пакет\nyum remove package_name\nвывести список всех пакетов, установленных в систему\nyum list\nнайти пакет в репозитории\nyum search package_name\nочисть rpm-кэш, удалив закачанные пакеты\nyum clean packages\nудалить все заголовки файлов, которые система использует для разрешения зависимостей\nyum clean headers\nочисть rpm-кэш, удалив закачанные пакеты и заголовки\nyum clean all\nDEB пакеты (Debian, Ubuntu и тому подобное) установить / обновить пакет\ndpkg -i package.deb удалить пакет из системы\ndpkg -r package_name\nпоказать все пакеты, установленные в систему\ndpkg -l\nсреди всех пакетов, установленных в системе, найти пакет содержащий в своѐм имени «apache2»\ndpkg -l | | grep apache2\nотобразить инфрмацию о конкретном пакете\ndpkg -s package_name\nвывести список файлов, входящих в пакет, установленный в систему\ndpkg -L package_name\nотобразить список файлов, входящих в пакет, который ешѐ не установлен в систему\ndpkg --contents package.deb\nнайти пакет, в который входит указанный файл\ndpkg -S /bin/ping\nAPT — средство управление пакетами (Debian, Ubuntu и тому подобное)\n\nустановить / обновить пакет apt-get install package_name\nустановить / обновить пакет с cdrom’а apt-cdrom install package_name\nполучить обновлѐнные списки пакетов apt-get update\nобновить пакеты, установленные в систему apt-get upgrade\nудалить пакет, установленный в систему с сохранением файлов конфигурации apt-get remove package_name\nудалить пакет, установленный в систему с удалением файлов конфигурации apt-get purge package_name\nпроверить целостность зависимостей apt-get check\nудалить загруженные архивные файлы пакетов apt-get clean\nудалить старые загруженные архивные файлы пакетов apt-get autoclean\nPacman — средство управление пакетами (Arch Linux, Chakra, Frugalware и alike) установить пакет из репозитория. Если после команды добавить --noconfirm, то не потребуется подтверждать действия.\npacman -S package_name\nустановить пакет из текущей деиректории\npacman -U package_name удалить пакет\npacman -R package_name\nудалить пакет с зависимостями, которые более не требуются\npacman -Rs package_name найти пакет\npacman -Ss package_name\nполучить обновленные списки пакетов\npacman -Sy обновить пакеты\npacman -Su\nПросмотр содержимого файлов\nвывести содержимое файла file1 на стандартное устройсво вывода\ncat file1\nвывести содержимое файла file1 на стандартное устройсво вывода в обратном порядке (последняя строка становиться первой и т.д.)\ntac file1\nпостраничный вывод содержимого файла file1 на стандартное устройство вывода\nmore file1\nпостраничный вывод содержимого файла file1 на стандартное устройство вывода, но с возможностью пролистывания в обе стороны (вверх-вниз), поиска по содержимому и т.п.\nless file1\n\nвывести первые две строки файла file1 на стандартное устройство вывода. По-умолчанию выводится десять строк\nhead -2 file1\nвывести последние две строки файла file1 на стандартное устройство вывода. По- умолчанию выводится десять строк\ntail -2 file1\nвыводить содержимое файла /var/log/messages на стандартное устройство вывода по мере появления в нѐм текста\ntail -f /var/log/messages\nМанипуляции с текстом\nобщий синтаксис выполнения действий по обработке содержимого файла и вывода результата в новый\ncat file_originale | [operation: sed, grep, awk, grep и т.п.] > result.txt\nобщий синтаксис выполнения действий по обработке содержимого файла и вывода результата в существующий файл. Если файл не существует, он будет создан\ncat file_originale | [operazione: sed, grep, awk, grepи т.п.] >> result.txt\nиз файла ‘/var/log/messages’ отобрать и вывести на стандартное устройство вывода строки, содержащие «Aug»\ngrep Aug /var/log/messages\nиз файла ‘/var/log/messages’ отобрать и вывести на стандартное устройство вывода строки, начинающиеся на «Aug»\ngrep ^Aug /var/log/messages\nиз файла ‘/var/log/messages’ отобрать и вывести на стандартное устройство вывода строки, содержащие цифры\ngrep [0-9] /var/log/messages\nотобрать и вывести на стандартное устройство вывода строки, содержащие «Augr», во всех файлах, находящихся в директории /var/log и ниже\ngrep Aug -R /var/log/*\nв файле example.txt заменить «string1» на «string2», результат вывести на стандартное устройство вывода\nsed 's/stringa1/stringa2/g' example.txt удалить пустые строки из файла example.txt\nsed '/^$/d' example.txt\nудалить пустые строки и комментарии из файла example.txt\nsed '/ *#/d; /^$/d' example.txt\nпреобразовать символы из нижнего регистра в верхний\necho 'esempio' | tr '[:lower:]' '[:upper:]' удалить первую строку из файла example.txt\nsed -e '1d' result.txt\nотобразить только строки содержашие «string1»\nsed -n '/string1/p'\nудалить пустые символы в в конце каждой строки\nsed -e 's/ *$//' example.txt\nудалить строку «string1» из текста не изменяя всего остального\nsed -e 's/string1//g' example.txt\nвзять из файла с первой по восьмую строки и из них вывести первые пять\n\nsed -n '1,8p;5q' example.txt вывести пятую строку\nsed -n '5p;5q' example.txt\nзаменить последовательность из любого количества нулей одним нулѐм\nsed -e 's/0*/0/g' example.txt\nпронумеровать строки при выводе содержимого файла\ncat -n file1\nпри выводе содержимого файла, не выводить чѐтные строки файла\ncat example.txt | awk 'NR%2==1'\nвывести первую колонку. Разделение, по-умолчанию, по проблелу/пробелам или символу/символам табуляции\necho a b c | awk '{print $1}'\nвывести первую и треью колонки. Разделение, по-умолчанию, по проблелу/пробелам или символу/символам табуляции\necho a b c | awk '{print $1,$3}'\nобъединить содержимое file1 и file2 в виде таблицы: строка 1 из file1 = строка 1 колонка 1- n, строка 1 из file2 = строка 1 колонка n+1-m\npaste file1 file2\nобъединить содержимое file1 и file2 в виде таблицы с разделителем «+»\npaste -d '+' file1 file2\nотсортировать содержимое двух файлов\nsort file1 file2\nотсортировать содержимое двух файлов, не отображая повторов\nsort file1 file2 | uniq\nотсортировать содержимое двух файлов, отображая только уникальные строки (строки, встречающиеся в обоих файлах, не выводятся на стандартное устройство вывода)\nsort file1 file2 | uniq -u\nотсортировать содержимое двух файлов, отображая только повторяющиеся строки\nsort file1 file2 | uniq -d\nсравнить содержимое двух файлов, не отображая строки принадлежащие файлу ‘file1’\ncomm -1 file1 file2\nсравнить содержимое двух файлов, не отображая строки принадлежащие файлу ‘file2’\ncomm -2 file1 file2\nсравнить содержимое двух файлов, удаляя строки встречающиеся в обоих файлах\ncomm -3 file1 file2\nПреобразование наборов символов и файловых форматов\nконвертировать файл текстового формата из MSDOS в UNIX (разница в символах возврата коретки)\ndos2unix filedos.txt fileunix.txt\nконвертировать файл текстового формата из UNIX в MSDOS (разница в символах возврата коретки)\nunix2dos fileunix.txt filedos.txt\nконвертировать содержимое тестового файла page.txt в html-файл page.html\nrecode ..HTML < page.txt > page.html вывести список доступных форматов\nrecode -l | more\n\nАнализ файловых систем\nпроверить раздел hda1 на наличие bad-блоков\nbadblocks -v /dev/hda1\nпроверить/восстановить целостность linux-файловой системы раздела hda1\nfsck /dev/hda1\nпроверить/восстановить целостность файловой системы ext2 раздела hda1\nfsck.ext2 /dev/hda1 или e2fsck /dev/hda1\nпроверить/восстановить целостность файловой системы ext3 раздела hda1 с указанием, что журнал расположен там же\ne2fsck -j /dev/hda1\nпроверить/восстановить целостность файловой системы ext3 раздела hda1\nfsck.ext3 /dev/hda1\nпроверить/восстановить целостность файловой системы fat раздела hda11\nfsck.vfat /dev/hda1\nФорматирование файловых систем\nсоздать linux-файловую систему на разделе hda1\nmkfs /dev/hda1\nсоздать файловую систему ext2 на разделе hda1\nmke2fs /dev/hda1\nсоздать журналирующую файловую систему ext3 на разделе hda1\nmke2fs -j /dev/hda1\nсоздать файловую систему FAT32 на разделе hda1\nmkfs -t vfat 32 -F /dev/hda1\nформатирование флоппи-диска без проверки\nfdformat -n /dev/fd0\nсоздание swap-пространства на разделе hda3\nmkswap /dev/hda3\nswap-пространство\nсоздание swap-пространства на разделе hda3\nmkswap /dev/hda3\nактивировать swap-пространство, расположенное на разделе hda3\nswapon /dev/hda3\nактивировать swap-пространства, расположенные на разделах hda2 и hdb3\nswapon /dev/hda2 /dev/hdb3\nСоздание резервных копий (backup)\nсоздать полную резервную копию директории /home в файл /tmp/home0.bak\ndump -0aj -f /tmp/home0.bak /home\nсоздать инкрементальную резервную копию директории /home в файл\ndump -1aj -f /tmp/home0.bak /home\nвосстановить из резервной копии /tmp/home0.bak\nrestore -if /tmp/home0.bak синхронизировать /tmp с /home\nrsync -rogpav --delete /home /tmp синхронизировать через SSH-туннель\nrsync -rogpav -e ssh --delete /home ip_address:/tmp\n\nсинхронизировать локальную директорию с удалѐнной директорией через ssh-туннель со сжатием\nrsync -az -e ssh --delete ip_addr:/home/public /home/local\nсинхронизировать удалѐнную директорию с локальной директорией через ssh-туннель со сжатием\nrsync -az -e ssh --delete /home/local ip_addr:/home/public\nсделать «слепок» локального диска в файл на удалѐнном компьютере через ssh-туннель\ndd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz'\nсоздать инкрементальную резервную копию директории ‘/home/user’ в файл backup.tar с сохранением полномочий\ntar -Puf backup.tar /home/user\nкопирование содержимого /tmp/local на удалѐнный компьютер через ssh-туннель в /home/share/\n( cd /tmp/local/ && tar c . ) | ssh -C user@ip_addr 'cd /home/share/ && tar x -p'\nкопирование содержимого /home на удалѐнный компьютер через ssh-туннель в /home/backup-home\n( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home && tar x -p' копирование одной директории в другую с сохранением полномочий и линков\ntar cf - . | (cd /tmp/backup ; tar xf - )\nпоиск в /home/user1 всех файлов, имена которых оканчиваются на ‘.txt’, и копирование их в другую директорию\nfind /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents\nпоиск в /var/log всех файлов, имена которых оканчиваются на ‘.log’, и создание bzip- архива из них\nfind /var/log -name '*.log' | tar cv --files-from=- | bzip2 > log.tar.bz2 создать копию MBR (Master Boot Record) с /dev/hda на флоппи-диск\ndd if=/dev/hda of=/dev/fd0 bs=512 count=1 восстановить MBR с флоппи-диска на /dev/hda\ndd if=/dev/fd0 of=/dev/hda bs=512 count=1 Сеть\nпоказать конфигурацию сетевого интерфейса eth0 ifconfig eth0\nактивировать (поднять) интерфейс eth0 ifup eth0\nдеактивировать (опустить) интерфейс eth0 ifdown eth0\nвыставить интерфейсу eth0 ip-адрес и маску подсети ifconfig eth0 192.168.1.1 netmask 255.255.255.0\nперевести интерфейс eth0 в promiscuous-режим для «отлова» пакетов (sniffing) ifconfig eth0 promisc\nотключить promiscuous-режим на интерфейсе eth0 ifconfig eth0 -promisc\nактивировать интерфейс eth0 в dhcp-режиме. dhclient eth0\nвывести локальную таблицу маршрутизации route -n\n\nзадать ip-адрес шлюза по умолчанию (default gateway) route add -net 0/0 gw IP_Gateway\nдобавить статический маршрут в сеть 192.168.0.0/16 через шлюз с ip-адресом 192.168.1.1 route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1\nудалить ip-адрес шлюза по умолчанию (default gateway) route del 0/0 gw IP_gateway\nразрешить пересылку пакетов (forwarding) echo \"1\" > /proc/sys/net/ipv4/ip_forward\nотобразить имя компьютера hostname\nразрешить имя http://www.linuxguide.it хоста в ip-адрес и наоборот host http://www.linuxguide.it\nотобразить состояние всех интерфейсов ip link show\nотобразить статус и тип соединения для интерфейса eth0 mii-tool eth0\nотображает статистику интерфеса eth0 с выводом такой информации, как поддерживаемые и текущие режимы соединения\nethtool eth0\nотображает все установленные сетевые соединения по протоколам TCP и UDP без разрешения имѐн в ip-адреса и PID’ы и имена процессов, обеспечивающих эти соединения\nnetstat -tupn\nотображает все сетевые соединения по протоколам TCP и UDP без разрешения имѐн в ip- адреса и PID’ы и имена процессов, слушающих порты\nnetstat -tupln\nотобразить весь трафик на TCP-порт 80 (обычно — HTTP)\ntcpdump tcp port 80\nпросканировать эфир на предмет, доступности беспроводных точек доступа\niwlist scan\nпоказать конфигурацию беспроводного сетевого интерфейса eth1\niwconfig eth1\nIPTABLES (firewall) отобразить все цепочки правил\niptables -nL\nотобразить все цепочки правил в NAT-таблице\niptables -t nat -L\nочистить все цепочки правил в filter-таблице\niptables -t filter -F\nочистить все цепочки правил в NAT-таблице\niptables -t nat -F\nудалить все пользовательские цепочки правил в filter-таблице\niptables -t filter -X\nпозволить входящее подключение telnet’ом\niptables -t filter -A INPUT -p tcp --dport telnet -j ACCEPT блокировать исходящие HTTP-соединения\niptables -t filter -A OUTPUT -p tcp --dport http -j DROP\n\nпозволить «прокидывать» (forward) POP3-соединения iptables -t filter -A FORWARD -p tcp --dport pop3 -j ACCEPT\nвключить журналирование ядром пакетов, проходящих через цепочку INPUT, и добавлением к сообщению префикса «DROP INPUT»\niptables -t filter -A INPUT -j LOG --log-prefix \"DROP INPUT\"\nвключить NAT (Network Address Translate) исходящих пакетов на интерфейс eth0. Допустимо при использовании с динамически выделяемыми ip-адресами\niptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE перенаправление пакетов, адресованных одному хосту, на другой хост\niptables -t nat -A PREROUTING -d 192.168.0.1 -p tcp -m tcp --dport 22 -j DNAT --to- destination 10.0.0.2:22\nМониторинг и отладка\nотобразить запущенные процессы, используемые ими ресурсы и другую полезную информацию (с автоматическим обновлением данных)\ntop\nотобразить запущенные процессы, используемые ими ресурсы и другую полезную информацию (единожды)\nps -eafw\nвывести PID’ы и процессы в виде дерева\nps -e -o pid,args --forest отобразить дерево процессов\npstree\n«убить» процесс с PID 98989 «на смерть» (без соблюдения целостности данных)\nkill -9 98989 или kill -KILL 98989 корректно завершить процесс с PID 98989\nkill -TERM 98989\nзаставить процесс с PID 98989 перепрочитать файл конфигурации\nkill -1 98989 или kill -HUP 98989\nотобразить список файлов, открытых процессом с PID 98989\nlsof -p 98989\nотобразить список открытых файлов из директории /home/user1\nlsof /home/user1\nвывести список системных вызовов, созданных и полученных процессом ls\nstrace -c ls >/dev/null вывести вызовы бибилотек\nstrace -f -e open ls >/dev/null\nотображать прерывания в режиме реального времени\nwatch -n1 'cat /proc/interrupts'\nотобразить историю перезагрузок системы\nlast reboot\nотобразить историю регистрации пользователя user1 в системе и время его нахождения в ней\nlast user1\nвывести загруженные модули ядра\nlsmod\nпоказать состояние оперативной памяти в мегабайтах\n\nfree -m\nконтроль состояния жѐсткого диска /dev/hda через SMART\nsmartctl -A /dev/hda\nпроверить доступность SMART на жѐстком диске /dev/hda\nsmartctl -i /dev/hda\nвывести десять последних записей из журнала загрузки ядра\ntail /var/log/dmesg\nвывести десять последних записей из системного журнала\ntail /var/log/messages\nДругие полезные команды\nвывести список комманд, которые так или иначе относятся к ключевым словам. Полезно, когда вы знаете что делает программа, но не помните команду\napropos ...keyword\nвызов руководства по работе с программой, в данном случае, — ping\nman ping\nотображает описание действий указанной программы\nwhatis ...keyword\nсоздаѐт загрузочный флоппи-диск\nmkbootdisk --device /dev/fd0 `uname -r`\nзашифровать файл file1 с помощью GNU Privacy Guard\ngpg -c file1\nдешифровать файл file1 с помощью GNU Privacy Guard\ngpg file1.gpg\nзагружает рекурсивно содержимое сайта http://www.example.com\nwget -r http://www.example.com\nзагрузить файл http://www.example.com/file.iso с возможностью останова и продолжения в последствии\nwget -c http://www.example.com/file.iso начать закачку в указанное время\necho 'wget -c http://www.example.com/files.iso' | at 09:00 вывести список библиотек, необходимых для работы ssh\nldd /usr/bin/ssh\nназначить алиас hh команде history\nalias hh='history'\n",
    "1. 2.\nЛЕКЦИЯ No6\n«Основные конфигурационные файлы Linux» по дисциплине\n«Основы администрирования программно-аппаратных комплексов под управлением ОС Linux»\nКонфигурационные файлы Linux\nПринципы редактирования конфигурационных файлов Linux\n1.Конфигурационные файлы Linux\nПоскольку операционная система — это всего лишь набор программ и ядро, то все конфигурационные файлы были созданы определенными программами и читаются ими же для настройки поведения. Большинство файлов, которые мы привыкли считать стандартными, относятся к системе инициализации или к другим системным утилитам. Большинство файлов размещено в /etc. Название этой папки расшифровывается как «et cetera», что с латинского означает «и другие» или «и так далее».\nЕсли просмотреть содержимое etc – нетрудно потеряться. Рассмотрим основные конфигурационные файлы.\n/etc/adjtime\nЭтот конфигурационный файл отвечает за настройку формата системного времени и читается службой systemd-timedated. Время может быть представлено в двух вариантах: LOCAL — время текущего часового пояса и UTC — время по Гринвичу.\n/etc/bash.bashrc\nЭтот файл принадлежит командной оболочке bash. Это не совсем конфигурационный файл — а скрипт, его содержимое выполняется при запуске каждого экземпляра bash для настройки оболочки. Точно так же выполняется содержимое файла ~/.bashrc для каждого пользователя.\n/etc/crontab\nCrontab — файл настройки планировщика cron. Здесь записываются все задания, которые должен выполнить планировщик, а также время и периодичность. Этот файл не принято редактировать напрямую. Для этого используется утилита crontab -e.\n/etc/environment\nЗдесь содержатся переменные окружения, которые будут загружены для каждого сеанса терминала, независимо от того запущен он на локальной машине или по ssh. Файл читается скриптами Bash во время инициализации оболочки.\n/etc/fstab\nНаверное, все уже знают файл /etc/fstab. Здесь выполняется настройка монтирования файловых систем во время загрузки. В современных системах он читается systemd и все записи на ходу транслируются в юнит-файлы, с помощью которых уже выполняется монтирование.\n/etc/group\n\nВ этом файле хранятся все группы пользователей, которые есть в системе. С помощью него вы можете посмотреть список групп, их идентификаторы или добавить новые. Но добавлять группы с помощью редактирования файла не принято, для этого есть утилита usermod.\n/etc/hostname\nВ этом файле содержится имя хоста, файл будет прочитан во время загрузки системы и указанное имя компьютера установится в системе. Вы будете его видеть в приглашении ввода терминала или в информации о системе.\n/etc/hosts\nФайл /etc/hosts позволяет задавать псевдонимы для различных сетевых узлов. Таким образом, компьютер не обращается к DNS для получения IP домена, а берет его из hosts. Это позволяет, например, заблокировать доступ к нежелательным сайтам просто перенаправив их на localhost или же получить доступ к сайту по ip, которому еще не присвоен домен. /etc/hosts.allow И /etc/hosts.deny\nС помощью этих двоих файлов можно настраивать права доступа ко всем локальным службам. Например, вы можете разрешить доступ к службе apache только с локального компьютера. Это очень сильно повысит безопасность системы, если ваш компьютер подключен к публичной сети.\n/etc/issue И /etc/issue.net\nБаннер, который будет выводиться при входе в командную оболочку локально или по SSH. Обычно там выводится версия ядра и дистрибутива Linux, но вы можете заменить эту информацию по своему усмотрению.\n/etc/ls.so.conf\nВ этом файле содержатся пути к папкам, в которых компоновщик linux ld.so будет искать динамические библиотеки во время запуска программ. Папки /lib64, /lib, /usr/lib64 и /usr/lib будут проверены автоматически.\n/etc/localtime\nЭто символическая ссылка, которая указывает на файл часового пояса в папке /usr/share/zoneinfo/. Редактировать файл не нужно, а для изменения настроек нужно создать символическую ссылку на другую временную зону.\n/etc/login.defs\nФайл /etc/login.defs отвечает за настройку поведения утилиты управления пользователями и параметры входа в систему. Вы можете настроить какой минимальный и максимальный id нужно выдавать, что делать с папкой пользователя при удалении и многое другое, количество попыток входа и таймаут, а также многое другое.\n/etc/mime.types\nВ этом файле содержатся общесистемные правила преобразования расширений файлов в понятные системе MIME типы данных. Затем уже система выбирает, чем открыть тот или иной тип данных.\n/etc/modprobe.d/\nПапка /etc/modprobe содержит конфигурационные файлы со списками модулей ядра, которые не нужно загружать при старте системы, псевдонимами для существующих модулей, а также позволяет задавать настройки для модулей.\n/etc/modules-load.d\n\nПапка /etc/modules-load.d/ содержит файлы со списками модулей, которые должны быть загружены при запуске системы. Имя файла не важно, но он должен иметь расширение .conf.\n/etc/nsswitch.conf\nЭтот файл задает настройки порядка разрешения имен в системе для всех программ, написанных на Си или С++. Например, нужно сначала просматривать локальную сеть и систему, или сразу же отправлять запрос к DNS.\n/etc/ntp.conf\nФайл ntp.conf отвечает за настройку службы синхронизации времени — ntpd. В файле указаны адреса ntp серверов, с которых служба будет получать время, а также общие настройки.\n/etc/os-release\nОтображает очень подробную информацию об установленном дистрибутиве:\n/etc/passwd\nФайл содержит список всех зарегистрированных в системе пользователей, а также дополнительные настройки для них, например, оболочку, дату смены пароля и дату отключения аккаунта, кроме самого пароля. Напрямую файл лучше не редактировать, а использовать утилиту для управления пользователями adduser или deluser.\n/etc/profile\nФайл /etc/profile, точно так же как и /etc/environment загружается и выполняется при запуске любой командной оболочки в системе. Но в отличие от environment, это скрипт, а значит, он может задавать не только переменные, но и выполнять различные команды для инициализации оболочки.\n/etc/resolv.conf\nВ этом файле содержатся IP адреса DNS серверов, которые будет использовать компьютер. В большинстве дистрибутивов вы можете редактировать файл вручную или же использовать специальные утилиты.\n/etc/sddm.conf\nЭто конфигурационный файл Linux для настройки менеджера входа sddm, для других менеджеров входа будут свои файлы настройки. Здесь можно изменить максимальный и минимальный ID пользователя, который может войти в систему, например, чтобы разрешить авторизацию root, изменить тему, добавить вход без пароля и многое другое. /etc/shadow\nРаньше пароли пользователя содержались в файле /etc/passwd, но поскольку к нему мог получить доступ любой пользователь, это было небезопасно, несмотря на то, что пароли зашифрованы. Поэтому все пароли были вынесены в /etc/shadow. Вы можете изменить пароль пользователя.\n/etc/sudoers\n/etc/sudoers — это файл настройки прав доступа к утилите sudo. Эта утилита позволяет выполнять команды от имени других пользователей, в том числе от имени суперпользователя. Но использовать ее могут только те пользователи, которые прописаны в этом файле.\n/etc/sysctl.conf\nЭтот файл отвечает за настройку параметров ядра во время выполнения. Тут вы можете задать все параметры из подсистемы /sys/ и они будут сохранены после перезагрузки. /etc/vconsole.conf\n\nУ этого файла только одна цель — задать кодировку, раскладку клавиатуры и шрифт по умолчанию для всех виртуальных консолей, запускаемых на машине.\n/boot/grub/grub.cfg\nЭтот конфигурационный файл Linux находится не в /etc из-за своего особого предназначения. Здесь содержатся все настройки загрузчика, пункты меню и другие параметры, поэтому он должен быть доступен еще до того как была подключена корневая файловая система.\n2.Принципы редактирования конфигурационных файлов Linux\nПрактически все настройки практически всех приложений, включая системные компоненты, хранятся в виде обычных текстовых файлов различного формата, называемых конфигурационными файлами или просто «конфигами». Это очень удобно, поскольку позволяет просто читать и менять их не только из конкретного приложения. Нормальные программы обычно содержат встроенный редактор параметров, основные настройки системы так же можно легко изменить с помощью графических утилит, доступных из меню «Система». Однако некоторые операции требуют редактирования системных файлов конфигурации, к которым нет доступа из графического окружения. Большинство конфигурационных файлов, которые приходится редактировать вручную, к тому же доступны для изменения только пользователю с привилегиями root. Если вам неоходимо отредактировать подобный файл, то вы можете поступить несколькими способами:\nСамый простой путь: вызвать диалог запуска программ (по умолчанию - Alt+F2) и запустить обычный текстовый редактор с правами суперпользователя командой:\ngksu gedit /путь/до/файла\nПользователи Kubuntu должны подставить вместо gedit текстовый редактор KDE kate. У вас попросят ввести ваш пароль и, если вы являетесь администратором компьютера, откроется для редактирования нужный файл.\nТо же самое можно сделать из терминала, запустив редактор командой\nsudo gedit /путь/до/файла\nВ этом случае вместо графического окна с запросом пароля у вас появится запрос непосредственно в терминале.\nПри введении пароля в терминале на экране ничего не отображается, ни звѐздочек, ни чѐрточек, ни каких-либо других символов, это нормально и так и должно быть, просто вводите пароль и нажимайте Enter\nНу и наконец можно отредактировать текстовый файл непосредственно из терминала, не открывая графических приложений вообще. Существует масса текстовых редакторов для терминала, самыми популярными в среде линуксойдов являются vi и emacs, однако ни первым, ни вторым новичку пользовать в принципе нереально, поэтому лучше всего использовать простой в освоении редактор nano, доступный по умолчанию в любой версии Ubuntu. Для открытия текстового файла с правами суперпользователя в nano просто наберите в терминале\nsudo nano /путь/до/файла\nЕсли для доступа к конфигурационному файлу требуются права администратора, то, скорее всего, в нѐм содержатся какие-то важные системные настройки. Будьте предельно внимательны при редактировании таких файлов, ошибка может привести к\n\nнеработоспособности всей системы. Если всѐ же случилось так, что вы записали в конфиг что-то не то - всегда можно загрузиться с LiveCD и исправить любой файл.\nДля редактирование некоторых конфигурационных файлов права администратора не требуются и поэтому являются излишними, в этом случае достаточно просто убрать sudo или gksu из начала команды и всѐ делать так же, как уже описано.\nКритические системные файлы\nСуществует несколько критических конфигурационных файлов, от содержимого которых зависит в системе очень многое, классическим примером является файл /etc/sudoers. Для редактирования конкретно этого файла существует специально адаптированная версия редактора vi, которую можно вызвать командой\nsudo visudo\nБудьте предельно внимательны при изменении подобных файлов, неправильная информация в /etc/sudoers может крайне просто привести к невозможности выполнить что-либо в системе.\n",
    "ЛЕКЦИЯ No7\n«Развертывание и тонкая настройка ОС Linux» по дисциплине\n«Основы администрирования программно-аппаратных комплексов под управлением ОС Linux»\n1.Настройка файервола iptables.\n2. Полезные программы и утилиты Linux\n1.Настройка файервола iptables.\nIptables — утилита командной строки, является стандартным интерфейсом управления работой межсетевого экрана (брандмауэра) Netfilter для ядер Linux, начиная с версии 2.4. С еѐ помощью администраторы создают и изменяют правила, управляющие фильтрацией и перенаправлением пакетов. Для работы с семейством протоколов IPv6 существует отдельная версия утилиты — Ip6tables. Для использования утилиты Iptables требуются привилегии суперпользователя (root).\nОсновные понятия\nКлючевыми понятиями iptables являются:\nПравило — состоит из критерия, действия и счетчика. Если пакет соответствует критерию, к нему применяется действие, и он учитывается счетчиком. Критерия может и не быть — тогда неявно предполагается критерий «все пакеты». Указывать действие тоже не обязательно — в отсутствие действия правило будет работать только как счетчик. Правила для каждой цепочки срабатывают в порядке их следования, поэтому порядок важен.\nКритерий — логическое выражение, анализирующее свойства пакета и/или соединения и определяющее, подпадает ли данный конкретный пакет под действие текущего правила. Критерии соединяются логическим «И».\nДействие — описание действия, которое нужно проделать с пакетом и/или соединением в том случае, если они подпадают под действие этого правила. О действиях более подробно будет рассказано ниже.\nСчетчик — компонент правила, обеспечивающий учет количества пакетов, которые попали под критерий данного правила. Также счетчик учитывает суммарный объем таких пакетов в байтах.\nЦепочка — упорядоченная последовательность правил. Цепочки можно разделить на пользовательские и базовые.\nБазовая цепочка — цепочка, создаваемая по умолчанию при инициализации таблицы. Каждый пакет, в зависимости от того, предназначен ли он самому хосту, сгенерирован им или является транзитным, должен пройти положенный ему набор базовых цепочек различных таблиц. Кроме того, базовая цепочка отличается от пользовательской наличием «действия по умолчанию» (default policy). Это действие применяется к тем пакетам, которые не были обработаны другими правилами этой цепочки и вызванных из нее\n    \nцепочек. Имена базовых цепочек всегда записываются в верхнем регистре (PREROUTING, INPUT, FORWARD, OUTPUT, POSTROUTING).\nПользовательская цепочка — цепочка, созданная пользователем. Может использоваться только в пределах своей таблицы. Рекомендуется не использовать для таких цепочек имена в верхнем регистре, чтобы избежать путаницы с базовыми цепочками и встроенными действиями.\nТаблица — совокупность базовых и пользовательских цепочек, объединенных общим функциональным назначением. Имена таблиц (как и модулей критериев) записываются в нижнем регистре, так как в принципе не могут конфликтовать с именами пользовательских цепочек. При вызове команды iptables таблица указывается в формате -t имя_таблицы. При отсутствии явного указания, используется таблица filter.\nБазовая конфигурация\nНиже приведѐн пример базовой статической конфигурации iptables. При сохранении и загрузке подобной конфигурации необходимо принимать во внимание возможность внесения в неѐ изменений со стороны других сервисов, например Fail2ban. Кроме того, при использовании IPv6-адресации конфигурацию для IPv6 следует выполнять независимо от IPv4.\nIPv4\nПросмотр текущей конфигурации:\nsudo iptables-save\nСоздаѐм скрипт с дампом правил iptables:\nsudo nano /etc/network/if-up.d/iptables-rules\nКопируем следующий код:\n#!/sbin/ip6tables-restore\n# Таблица filter и еѐ цепочки\n*filter\n:INPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n# Разрешаем связанные и установленые соединения\n-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\n# Разрешаем служебный icmp-трафик\n-A INPUT -p ipv6-icmp -j ACCEPT\n# Разрешаем доверенный трафик на интерфейс loopback\n-A INPUT -i lo -j ACCEPT\n# Сюда можно вставлять дополнительные правила для цепочки INPUT\n# Запрещаем всѐ остальное для INPUT\n-A INPUT -j REJECT --reject-with icmp6-adm-prohibited\n# Порядок и смысл правил для цепочек FORWARD и OUTPUT аналогичен INPUT\n-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\n-A FORWARD -p ipv6-icmp -j ACCEPT\n-A FORWARD -j REJECT --reject-with icmp6-adm-prohibited\n# Фильтровать цепочку OUTPUT настоятельно не рекомендуется\n#-A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\n#-A OUTPUT -p ipv6-icmp -j ACCEPT\n#-A OUTPUT -o lo -j ACCEPT\n \n#-A OUTPUT -j REJECT --reject-with icmp6-adm-prohibited COMMIT\nДополняем нужными правилами с учѐтом ip6tables-save. Сохраняем и закрываем: Ctrl+O, Enter, Ctrl+X\nДелаем скрипт исполняемым и загружаем правила iptables: sudo chmod +x /etc/network/if-up.d/ip6tables-rules\nsudo /etc/network/if-up.d/ip6tables-rules\nНебольшое замечание по терминологии. Фаервол, встроенный в ядро Linux, называется Netfilter, а iptables — утилита для управления этим фаерволом. Многие ошибочно полагают, что фаервол называется iptables. Это не так. Категорически не стоит что-нибудь наподобие «я фильтрую пакеты с помощью iptables».\n2. Полезные программы и утилиты Linux Программы для работы с сетью и интернетом\nТип программы Windows программа Linux программа\nMozilla Firefox, Opera, Chromium, Google Chrome, Lynx, Konqueror,\n      Web-браузер\nКлиент обмена мгновенными сообщениями\nIRC-клиент\nГолосовое/видео общение\nE-mail клиенты\nMidori, SRWare Iron\nInternetExplorer w3m, links, luakit\nPidgin, Gajim, qutIM, ICQ, Skype\nQIP, Miranda, Mail.ru агент, Windows Live Messenger\nEmpathy, Kopete, MyAgent-IM\n   Pidgin, Xchat\nMIRC Konversation Skype, SFLphone, Ekiga, Linphone, Jitsi, QuteCom\nTwinkle\nMozilla Thunderbird, SeaMonkey, Opera Mail, Sylpheed, Claws Mail\n   Microsoft Outlook, Outlook Express, The Bat!\nEvolution, KMail, Postler,Fetchmail\nGwget, Kget, D4X, FatRat, uGet,\n Менеджеры загрузок cURL, JDownloader, aria2, wget Download Master, Free Download\n   \n   Тип программы\ntorrent- клиенты\nDC- клиенты\ned2k-клиенты\nFTP-клиенты\nRSS-агрегаторы\nWindows программа Linux программа\nManager, FlashGet, Orbit SteadyFlow Downloader\nVuze, Deluge, qBittorrent, Transmission\n     BitTorrent, μTorrent\nEiskaltDC++\nDC++, StrongDC++, FlylinkDC++\naMule\neMule\nFilezilla\nTotal Commander Thunderbird, RSSOwl Outlook\nFlush, KTorrent, FatRat, rTorrent, CTorrent, MLDonkey\nLinuxDC++, Valknut, FreeDC++,Nicotine+, Museek+\nxMule, MLDonkey\nTucan Manager, gFTP\n     Клиенты облачных хранилищ данных\nLiferea, Akregator, Claws Mail Dropbox, Wuala, SpiderOak, Ubuntu One\n Windows Live Mesh, SugarSync Расширение возможностей\nownCloud\nLinux программа\nX Neural Switcher\n       Тип программы\nАвтоматический переключатель раскладки\nЗаметки\nWindows программа Punto Switcher\n  Tomboy, Zim, NeverNote, Makagiga\nEvernote Gnote, Xpad, MyTetra\n   \n   Тип программы\nУкрашения рабочего стола\nДок-бар\nОфисные приложения Тип программы\nЭлектронные словари\nТекстовые редакторы\nПакет офисных приложений\nCистема оптического распознавания текстов (OCR)\nОрганайзеры, записные книжки\nПерсональные информационные менеджеры (PIM)\nПодготовка публикаций\nWindows программа Linux программа\nWindows Aero, Боковая панель Compiz Fusion , Plasma, Screenlets, Windows, Aston Google Gadgets, Conky\n     RocketDock, ObjectDock\nCairo-Dock, Avant Window Navigator, Docky , wBar\n      Windows программа Linux программа GoldenDict, StarDict\nABBYY Lingvo\nGedit   , Medit, Vim, Geany, SciTE, Emacs\n  Notepad, Notepad++, AkelPad\nKate, Nano, JOE, Leafpad, Mousepad, Sublime Text 2\n  LibreOffice   , OpenOffice.org, GNOME Office, SoftMaker Office\n  Microsoft Office, Corel WordPerfect Office\nKoffice, Calligra\nCuneiform, Tesseract\nFineReader, Readiris YAGF\nSunbird, Tomboy, Lightning (Thunderbird) Rainlendar\n   Microsoft Outlook\nLaTeX, LyX, Kile, Scribus Adobe InDesign\nKdepim, Evolution, Osmo\n   \n   Тип программы Просмотр PDF/DJVU\nПрограммы для чтения FB2, TXT, RTF, TCR, HTML, EPUB\nWindows программа Linux программа Evince, Adobe Reader, Foxit Reader\nSTDU Viewer,WinDjView , Okular, Xpdf, Zathura, Sumatra PDF ePDFView, Gv\nFBReader, Cool Reader 3, Calibre KeePassX, LastPass\n    Менеджеры паролей\nПрограммы для работы с файлами\n  KeePass, Password Safe, Password Saver\nWindows программа Linux программа Nero Burning ROM\nCDBurnerXP, Deep\nBurner, Infra Recorder, Brasero   , K3b, GnomeBaker, Graveman, cdw ImgBurn\nPeaZip\n7-Zip, WinRAR, WinZIP tar   , Squeeze, p7zip, File Roller   , Ark, Xarchiver\nDouble Commander\nExplorer, Far manager, Nautilus   , Thunar, Dolphin, Konqueror, Total Commander, Unreal PCManFM, SpaceFM (развитие PCManFM), Commander emelFM2, Gentoo, Midnight Commander,\nSeahorse\n     Тип программы\nПрограммы для записи оптических дисков\n  Работа с архивами\nФайловые менеджеры\nМонтирование образов\nAlcohol 120%, Daemon Tools\nKrusader, Gnome-commander\nAcetoneISO, Furius ISO Mount, Mount, CDemu\n         Системные утилиты\n\n   Тип программы\nСоздание/изменение/удаление файловых систем\nВосстановление\nдля файловых систем\nБинарные редакторы\nРасширенные настройки системы\nАнтивирусы\nWindows программа Linux программа\n  PartitionMagic, Acronis Disk Director Suite\ngparted, KDE Partition Manager, Palimpsest Disk Utility, fdisk, cfdisk, sfdisk\n  R-Studio TestDisk, Ext3Grep, ExtUndelete, MagicResque\n  Ultimate Windows Tweaker, XP Tweaker\nBless, Okteta, Hexedit\nubuntu tweak, Ailurus, KernelCheck\n  ClamAV, DrWeb, Nod32, Avast, Avira AntiVir, Kaspersky Workstation, BitDefender\n ",
    "ЛЕКЦИЯ No8\n«Конфигурирование серверных ОС Linux» по дисциплине\n«Основы администрирования программно-аппаратных комплексов под управлением ОС Linux»\n1. Семейство серверных Linux\n2.Конфигурирование серверных ОС Linux посредством командной строки\n1. Семейство серверных Linux\nDEBIAN\nНесмотря на отсутствие коммерческой поддержки, вы можете пользоваться услугами консультантов по Debian со всего мира, которые указаны на странице Consultants. Debian был «рожден» в 1993 году и дал больше дистрибутивов-«потомков», чем другие.\nВ Debian произошел переход от SysVinit к systemd, а сам дистрибутив включает последние релизы Linux Kernel, Apache, LibreOffice, Perl, Python, Xen Hypervisor, GNU Compiler Collection, GNOME и Xfce. Debian 8.6 вышел в сентябре 2016 года.\nORACLE LINUX\nЕсли вы не знали, что Oracle имеет свой собственный Linux, вы – не одиноки. Это клон RHEL, с некоторым «добавками» от Oracle.\nОптимизированный для баз данных Oracle, Oracle Linux является значимым игроком на рынке серверного Linux. Последний релиз, 7.3, вышел в ноябре 2016 года и основан на RHEL 7.3. MAGEIA / MANDRIVA\nMageia – это появившийся в 2011 году форк с открытым кодом от Mandriva Linux. Mandriva широко популярна в Европе и в Южной Америке.\nMageia 5 доступна с июня 2015 г., а Mageia 6 ожидается в начале 2017 г.\nCLEAROS\nClearOS основана на RHELи CentOS. Удобный админский интерфейс и подробная документация делает ClearOS неплохим выбором для не очень опытных администраторов, либо пользователей, кому надо быстро поднять сервер на Linux без лишних «заморочек». ClearOS доступна бесплатно, и в то же время предлагает недорогую профессиональную версию с опциями поддержки и дополнительными функциями.\nПоследний релиз, 7.2, получил улучшенную поддержку виртуальных машин, включая Hyper- V, XFS, BTRFS, IPv6 и кэширования LVM.\nARCH LINUX\nПростой и «легкий» дистрибутив, который создан для более опытных пользователей. В Arch Linux нет поддержки или легкости использования других версий, но он вполне может использоваться опытными админами.\nКак и в Gentoo Linux, Arch Linux использует модель «rolling release», что означает, что регулярное обновление системы – это все, что требуется, чтобы получать последние компоненты и пакеты.\n\nSLACKWARE\nХотя Slackware редко ассоциируется с коммерческими продуктами, несколько компаний предоставляют платную поддержку для этой платформы.\nЭто один из самых ранних дистрибутивов для серверов, впервые выпущенный в 1993 году, поэтому у Slackware существует мощная база поклонников. Разработчики регулярно выпускают новые версии, последний релиз, 14.2, вышел в июле 2016 г.\nUBUNTU\nUbuntu превосходит остальные дистрибутивы Linux для серверов – начиная от простой инсталляции, до восстановления после проблем с оборудованием или классной поддержки. Последний релиз 16.10 поддерживает OpenStack Newton, Kubernetes и апдейты в виде Juju 2.0 и MaaS 2.0 для технологии Canonical Metal-as-a-Service.\nRED HAT ENTERPRISE LINUX\nОС Red Hat Enterprise Linux (RHEL) для серверов является одним из ключевых игроков на рынке дата-центров.\nRHEL основана на Fedora. Дебют ОС состоялся в июне 2014 года, с тех пор прошло несколько апдейтов, после которых ОС получила возможности масштабирования, включая новую файловую систему, которая может поддерживать до 500 терабайт, а также поддержку контейнеров Docker.\nSUSE LINUX ENTERPRISE SERVER\nЭто надежный дистрибутив, основан на openSUSE Linux с дополнительным фокусом на стабильности и поддержке.\nПоследний релиз вышел в октябре 2014 года и принес поддержку Docker, полное восстановление системы. Последний сервис-пак SLES 12 SP2 вышел в декабре 2016 года, в нем поддерживается Open vSwitch и стандарт криптопроцессоров Trusted Platform Module 2.0. CENTOS\nЕсли сайт работает на коммерческом хостинге, велики шансы, что веб-сервер, на котором расположен сайт, управляется CentOS Linux. Этот клон RHEL не является строго говоря коммерческим продуктом, но вы можете пользоваться платной поддержкой.\nCentOS 7.2 вышла в декабре 2015 года и основана на RHEL 7.2.\n2.Конфигурирование серверных ОС Linux посредством командной строки\nПосле установки серверной ОС Linux нельзя считать процесс законченным. Необходимо провести конфигурирование системы.\nПри входе в систему Linux-системах процесс ввода пароля никак визуально не отображается, вам просто нужно набрать нужную комбинацию символов и нажать Enter, хотя внешне система ведет себя так, как будто ничего не происходит. Такое поведение унаследовано от UNIX-систем.\nПосле входа в систему, в первую очередь стоит настроить сеть. Возможности установить дополнительные пакеты нет, поэтому необходимо использовать встроенные средства. По умолчании в системе имеется текстовый редактор nano, он не столь удобен, как встроенный редактор mc, но нужно уметь им пользоваться, как раз на случай таких ситуаций.\nПрежде всего повысим свои права до суперпользователя:\nsudo -s\nИ откроем редактором конфигурационный файл с настройками сети:\n\nnano /etc/network/interfaces\nДалее приведем его содержимое к следующему виду: auto lo\niface lo inet loopback\nauto eth0\niface eth0 inet static\naddress 192.168.44.62\nnetmask 255.255.255.0\ngateway 192.168.44.2 dns-nameservers 192.168.44.2 8.8.8.8\nПервая секция auto lo задает настройки для петлевого интерфейса и уже присутствует в файле. Вторая секция задает настройки внешнего сетевого интерфейса eth0 для работы со статическим адресом. Опции понятны и отдельных разъяснений не требуют, адреса, естественно, взяты исключительно для примера. Если в вашем сервере несколько сетевых адаптеров, то следует прописать секцию для каждого из них.\nДопустим мы хотим получать настройки второго сетевого адаптера eth1 по DHCP, для этого добавим секцию:\nauto eth1\nallow-hotplug eth1\niface eth1 inet dhcp\nНемного остановимся на опциях auto и auto-hotplug. Первая указывает инициировать подключение при загрузке, а вторая запускает механизм отслеживания горячего переподключения и инициировать получение адреса при наступлении данного события. Закончив редактировать файл следует выйти из редактора по Ctrl + X, утвердительно (Y) ответив на предложение записать файл.\nПосле чего перезагрузите компьютер:\nreboot\nЕсли все сделано правильно, то система получит доступ к сети и интернет. Проверить это можно командой ping:\nping ya.ru\nПрервать выполнение команды следует комбинацией Ctrl + С, запомните эту комбинацию, она еще не раз вам пригодится.\nПросмотреть настройки сетевых интерфейсов можно командой\nifconfig\nЭтой же командой можно выяснить, какие именно сетевые карты видит система и под какими именами, для этого воспользуйтесь параметром HWaddr, который представляет MAC-адрес сетевой платы.\nПеред тем, как приступить к дальнейшей настройке, систему следует обновить, для этого снова повысим права до суперпользователя и обновим список пакетов командой:\napt-get update\nЗатем обновим систему командой:\napt-get upgrade\nВнимательно изучаем вывод команды, как видим, по какой-то причине не обновляются три пакета, в данном случае это пакеты ядра. Поэтому попробуем обновить их вручную. Для этого выполним команду:\napt-get install linux-generic\n\nКоторая установит новое ядро и пакеты зависимостей к нему. После обновления систему также рекомендуется перезагрузить.\nПосле перезагрузки установим инструменты администрирования: пакет ssh для удаленного доступа к серверу и файловый менеджер mc, который значительно упрощает работу с системой.\napt-get install ssh mc\nДля запуска mc используйте простую команду:\nmc\nили\nsudo mc\nесли хотите запустить его с правами суперпользователя.\nНа этом предварительную настройку можно считать законченной.\n"
  ]
}